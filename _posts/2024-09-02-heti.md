---
title: 「工具」一款好用的中文排版工具
author: rainsin
date: 2024-09-08 12:32:10 +0800
categories: [工具, 排版]
tags: [工具]
pin: false
math: false
react: false
mermaid: false
video: false
music: false
cube: false
babel: false
imgcard: true
blockquote-sep: true
pangu: true

guwen: true
guwen-all: false
guwen-addon: true
pinyin: true

charch: true
indent: false
pseudo: false
vertical: false
cjk-latin-space: true
bracket-replace: true
link-space: true
line-height: true

mathpolt: false
jquery: true
forbid: false
comments: true
postsummary: false

favicon: heart

post: true
description: 「工具」一个好用中文排版工具
keywords: rainsin, blog, 工具
---

> 发现了一个古文排版工具，我自己做了很奇怪的指令用来自用，这个工具做出来的东西还挺好看的。后续我可能会有这方面的内容，现在做好为以后作准备。[工具仓库-赫蹏](https://github.com/sivan/heti)。
{: .prompt-tip }

## 介绍

<div class="heti-box">
@Hdiv(classic){@Hp(){@Hem(){@Hpy(){赫蹏}}是专为中文网页内容设计的排版样式增强。它基于通行的中文排版规范，可为网站的读者带来更好的内容阅读体验。它的主要特性有：}
@Hul(){
@Hli(){贴合网格的排版；}
@Hli(){全标签样式美化；}
@Hli(){预置古文、诗词样式；}
@Hli(){预置多种排版样式（行间注、多栏、竖排等）；}
@Hli(){多种预设字体族（仅限桌面端）；}
@Hli(){简/繁体中文支持；}
@Hli(){自适应黑暗模式；}
@Hli(){中西文混排美化，不再手敲空格（基于JavaScript脚本）；}
@Hli(){标点挤压（基于JavaScript脚本）；}
@Hli(){兼容@Hi(){normalize.css}、@Hi(){CSS Reset}等常见样式重置；}
@Hli(){移动端支持；}
@Hli(){……}
}
@Hp(){总之，用上就会变好看。}}
</div>

## 如何使用

> 在`head`中引入
{: .prompt-tip }

```html
<!-- 工具主体 -->
<link rel="stylesheet" href="https://cdn.jsdmirror.com/npm/heti@0.9.4/umd/heti.min.css">
```

> 可选以下工具，具体使用详见该库的npm页面
{: .prompt-tip }

```html
<!-- 优化中文排版的小问题，如首行缩进2字符 -->
<script type="text/javascript" src="https://cdn.jsdmirror.com/npm/charch@0.1.0/charch.build.js"></script>

<!-- 符号挤压 -->
<script src="https://cdn.jsdmirror.com/npm/heti@0.9.4/umd/heti-addon.min.js"></script>
```

## 指令详情

> 指令是我自己定义的，该工具只是一个css库。
{: .prompt-danger }

<div class="heti heti--ancient">

  <details>
          <summary>查看标签示例表</summary>
          <section class="section">
            <table>
              <caption>常用标签样式示例表</caption>
              <tr>
                <th style="width: 72px;text-align: center;">类型</th>
                <th style="width: 320px;text-align: center;">标签</th>
                <th style="width: 240px;text-align: center;">效果</th>
              </tr>
              <tr>
                <td style="text-align: center">标题</td>
                <td><code>@Hh5(){标题1-5级}</code></td>
                <td><h5>标题1-5级</h5></td>
              </tr>
              <tr>
                <td style="text-align: center">缩写</td>
                <td><code>@Habbr(Cascading Style Sheets){CSS}</code></td>
                <td><abbr title="Cascading Style Sheets">CSS</abbr></td>
              </tr>
              <tr>
                <td style="text-align: center">专名号</td>
                <td><code>@Hp(){此时来自@Hu(位于山东省聊城市阳谷县城东){景阳冈}的@Hu(){武松}大喝一声：@Hq(){纳命来！}}</code></td>
                <td>此时来自<u title="位于山东省聊城市阳谷县城东">景阳冈</u>的<u>武松</u>大喝一声：<q>纳命来！</q></td>
              </tr>
              <tr>
                <td style="text-align: center">文本更新</td>
                <td><code>因为谁也不认识，所以最后我们决定念@Hs(){dí}tí。</code></td>
                <td>因为谁也不认识，所以最后我们决定念<s>dí</s>tí。</td>
              </tr>
              <tr>
                <td style="text-align: center">引号</td>
                <td><code>窃·格瓦拉曾经说过：@Hq(){打工是不可能打工的。}</code></td>
                <td>窃·格瓦拉曾经说过：<q>打工是不可能打工的。</q></td>
              </tr>
              <tr>
                <td style="text-align: center">术语</td>
                <td><code>@Hdfn(){窃·格瓦拉}，中国大陆网络红人、罪犯。被奉为百度「戒赌吧」400万会员的「精神领袖」。</code></td>
                <td><dfn>窃·格瓦拉</dfn>，中国大陆网络红人、罪犯。被奉为百度「戒赌吧」400万会员的「精神领袖」。</td>
              </tr>
              <tr>
                <td style="text-align: center">标记</td>
                <td><code>这道题@Hmr(){必考}，你们爱记不记。</code></td>
                <td>这道题<mark>必考</mark>，你们爱记不记。</td>
              </tr>
              <tr>
                <td style="text-align: center">强调</td>
                <td><code>稳住，@Hem(){我们能赢}！</code></td>
                <td>稳住，<em>我们能赢</em>！</td>
              </tr>
              <tr>
                <td style="text-align: center">着重号</td>
                <td><code>我们@Htem(){必将}战胜这场疫情。</code></td>
                <td>我们<span class="heti-em">必将</span>战胜这场疫情。</td>
              </tr>
              
            </table>
          </section>
        </details>
  </div>

## 使用示例

### 横排

<div class="heti-box">
@Hdiv(ancient,annotation){
@Hh1(){庖丁解牛}

@Hp(meta,small){作者：@Habbr(庄子){庄周}（公元前369～公元前286年）}

@Hp(){@Hem(){吾生也有涯}，@Hem(){而知也无涯}。以有涯随无涯，殆已！已而为知者，殆而已矣！为善无近名，为恶无近刑。@Hmr(){缘督以为经，可以保身，可以全生，可以养亲，可以尽年。}}

@Hp(){@Hu(名丁的厨工。先秦古书往往以职业放在人名前){@Hpy(){庖}丁}为文惠君解牛，手之所触，肩之所倚，足之所履，膝之所@Hu(支撑，接触){@Hpy(){踦}}，@Hu(砉然：砉，又读xū，象声词。砉然，皮骨相离的声音){@Hpy(){砉}然@Hpy(xiǎng){向}然}，奏刀@Hu(騞然：象声词，形容比砉然更大的进刀解牛声){@Hpy(){騞}然}，莫不中音。合于《桑林》之舞，乃中《经首》之会。}

@Hp(){文惠君曰：「嘻，善哉！技@Hu(通「盍」，何，怎样){@Hpy(hé){盖}}至此乎？」}

@Hp(){庖丁释刀对曰：「臣之所好者，道也，进乎技矣。始臣之解牛之时，所见无非牛者。三年之后，未尝见全牛也。方今之时，臣以神遇而不以目视，官知止而@Hu(指精神活动){神欲}行。依乎@Hu(指牛的生理上的天然结构){天理}，@Hu(击入大的缝隙){批大@Hpy(){郤}}，@Hu(){导大@Hpy(){窾}}，@Hu(依){因}其@Hu(指牛体本来的结构){固然}，技经肯@Hpy(){綮}之未尝，而况大@Hpy(){軱}乎！良庖岁更刀，割也；族庖月更刀，折也。今臣之刀十九年矣，所解数千牛矣，而刀刃若新发于@Hpy(){硎}。彼节者有间，而刀刃者无厚；以无厚入有间，恢恢乎其于@Hem(){游刃必有余地}矣，是以十九年而刀刃若新发于硎。虽然，每至于族，吾见其难为，@Hpy(){怵}然为戒，视为止，行为迟。动刀甚微，@Hpy(){謋}然已解，如土委地。提刀而立，为之四顾，为之@Hpy(){踌躇}满志，善刀而藏之。」}

@Hp(){文惠君曰：「@Hpy(){善哉}！吾闻庖丁之言，得养生焉。」}}
</div>

### 指令

```
@Hdiv(ancient,annotation){
@Hh1(){庖丁解牛}

@Hp(meta,small){作者：@Habbr(庄子){庄周}（公元前369～公元前286年）}

@Hp(){@Hem(){吾生也有涯}，@Hem(){而知也无涯}。以有涯随无涯，殆已！已而为知者，殆而已矣！为善无近名，为恶无近刑。@Hmr(){缘督以为经，可以保身，可以全生，可以养亲，可以尽年。}}

@Hp(){@Hu(名丁的厨工。先秦古书往往以职业放在人名前){@Hpy(){庖}丁}为文惠君解牛，手之所触，肩之所倚，足之所履，膝之所@Hu(支撑，接触){@Hpy(){踦}}，@Hu(砉然：砉，又读xū，象声词。砉然，皮骨相离的声音){@Hpy(){砉}然@Hpy(xiǎng){向}然}，奏刀@Hu(騞然：象声词，形容比砉然更大的进刀解牛声){@Hpy(){騞}然}，莫不中音。合于《桑林》之舞，乃中《经首》之会。}

@Hp(){文惠君曰：「嘻，善哉！技@Hu(通「盍」，何，怎样){@Hpy(hé){盖}}至此乎？」}

@Hp(){庖丁释刀对曰：「臣之所好者，道也，进乎技矣。始臣之解牛之时，所见无非牛者。三年之后，未尝见全牛也。方今之时，臣以神遇而不以目视，官知止而@Hu(指精神活动){神欲}行。依乎@Hu(指牛的生理上的天然结构){天理}，@Hu(击入大的缝隙){批大@Hpy(){郤}}，@Hu(){导大@Hpy(){窾}}，@Hu(依){因}其@Hu(指牛体本来的结构){固然}，技经肯@Hpy(){綮}之未尝，而况大@Hpy(){軱}乎！良庖岁更刀，割也；族庖月更刀，折也。今臣之刀十九年矣，所解数千牛矣，而刀刃若新发于@Hpy(){硎}。彼节者有间，而刀刃者无厚；以无厚入有间，恢恢乎其于@Hem(){游刃必有余地}矣，是以十九年而刀刃若新发于硎。虽然，每至于族，吾见其难为，@Hpy(){怵}然为戒，视为止，行为迟。动刀甚微，@Hpy(){謋}然已解，如土委地。提刀而立，为之四顾，为之@Hpy(){踌躇}满志，善刀而藏之。」}

@Hp(){文惠君曰：「@Hpy(){善哉}！吾闻庖丁之言，得养生焉。」}}
```

### 竖排

<div class="heti-box">
@Hdiv(ancient,vertical){
@Hh1(){般若波罗蜜多心经}

@Hp(meta,small){译者：@Habbr(陈祎){玄奘}（602年～664年）}

@Hp(){观自在菩萨，行深般若波罗蜜多时，照见五蕴皆空，度一切苦厄。}

@Hp(){舍利子，@Htem(){色不异空，空不异色。色即是空，空即是色。受想行识，亦复如是。}}

@Hp(){舍利子，是诸法空相，不生不灭。不垢不净，不增不减。@Hmr(){是故空中无色，无受想行识。无眼耳鼻舌身意，无色声香味触法。无眼界，乃至无意识界。无无明，亦无无明尽。乃至无老死，亦无老死尽。无苦集灭道，无智亦无得，以无所得故。}}

@Hp(){菩提萨@Hpy(){埵}，依般若波罗蜜多故。心无挂碍，无挂碍故，无有恐怖。远离颠倒梦想，究竟涅槃。}

@Hp(){三世诸佛，依般若波罗蜜多故。得阿@Hpy(){耨}多罗三藐三菩提。}

@Hp(){故知般若波罗蜜多。是大神咒，是大明咒，是无上咒。是无等等咒，能除一切苦，真实不虚。}

@Hp(){故说般若波罗蜜多咒。即说咒曰，揭谛揭谛，波罗揭谛。波罗僧揭谛，菩提萨婆诃。}}
</div>

### 指令

```
@Hdiv(ancient,vertical){
@Hh1(){般若波罗蜜多心经}

@Hp(meta,small){译者：@Habbr(陈祎){玄奘}（602年～664年）}

@Hp(){观自在菩萨，行深般若波罗蜜多时，照见五蕴皆空，度一切苦厄。}

@Hp(){舍利子，@Htem(){色不异空，空不异色。色即是空，空即是色。受想行识，亦复如是。}}

@Hp(){舍利子，是诸法空相，不生不灭。不垢不净，不增不减。@Hmr(){是故空中无色，无受想行识。无眼耳鼻舌身意，无色声香味触法。无眼界，乃至无意识界。无无明，亦无无明尽。乃至无老死，亦无老死尽。无苦集灭道，无智亦无得，以无所得故。}}

@Hp(){菩提萨@Hpy(){埵}，依般若波罗蜜多故。心无挂碍，无挂碍故，无有恐怖。远离颠倒梦想，究竟涅槃。}

@Hp(){三世诸佛，依般若波罗蜜多故。得阿@Hpy(){耨}多罗三藐三菩提。}

@Hp(){故知般若波罗蜜多。是大神咒，是大明咒，是无上咒。是无等等咒，能除一切苦，真实不虚。}

@Hp(){故说般若波罗蜜多咒。即说咒曰，揭谛揭谛，波罗揭谛。波罗僧揭谛，菩提萨婆诃。}}
```

### 诗词

<div class="heti-box">
@Hdiv(poetry,nowarp){

@Hh1(){一剪梅·红藕香残玉簟秋@Hsp(meta,small){[宋]@Habbr(号易安居士){李清照}}}

@Hp(verse,x-large){红藕香残玉簟秋。轻解罗裳，独上兰舟@Hsp(hang){。}<br>云中谁寄锦书来，雁字回时，月满西楼@Hsp(hang){。}<br>花自飘零水自流。一种相思，两处闲愁@Hsp(hang){。}<br>此情无计可消除，才下眉头，却上心头@Hsp(hang){。}}
}
</div>

### 指令

```
@Hdiv(poetry,nowarp){

@Hh1(){一剪梅·红藕香残玉簟秋@Hsp(meta,small){[宋]@Habbr(号易安居士){李清照}}}

@Hp(verse,x-large){红藕香残玉簟秋。轻解罗裳，独上兰舟@Hsp(hang){。}<br>云中谁寄锦书来，雁字回时，月满西楼@Hsp(hang){。}<br>花自飘零水自流。一种相思，两处闲愁@Hsp(hang){。}<br>此情无计可消除，才下眉头，却上心头@Hsp(hang){。}}
}
```

### 仿宋

> 我自己加的。
{: .prompt-tip }

<div class="heti-box">
@Hdiv(ancient,fangsong){
@Hh1(){出师表}
@Hp(meta,small){作者：@Habbr(字孔明){諸葛亮}（181年～234年10月8日）}
@Hp(){先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。}
@Hp(){宫中府中，俱为一体；陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理；不宜偏私，使内外异法也。}
@Hp(){侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下：愚以为宫中之事，事无大小，悉以咨之，然后施行，必能裨补阙漏，有所广益。}
@Hp(){将军向宠，性行淑均，晓畅军事，试用于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。}
@Hp(){亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。}
@Hp(){臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。}
@Hp(){先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐托付不效，以伤先帝之明；故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。}
@Hp(){愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏。臣不胜受恩感激。}
@Hp(){今当远离，临表涕零，不知所言。}
}
</div>

### 指令

```
@Hdiv(ancient,fangsong){
    ······
}
```

## 代码

#### 需要的库

```html
<!-- Jquery -->
<script src="https://s4.zstatic.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>

<!-- 一个生成拼音的库 -->
<script src="https://cdn.jsdelivr.net/npm/pinyin-pro@3.18.2/dist/index.js"></script>

```

#### 具体实现

> 烂代码没啥鲁棒性，你可以自己实现一下，实现完了留言告诉我，我可以用一用。
{: .prompt-tip }

```javascript
//   定义栈的类
class bracketMatchStack {
    constructor() {
        this.stack = [];
    }
    push(item) {
        return this.stack.push(item);
    }
    pop() {
        return this.stack.pop();
    }
    // 查询栈顶的元素
    peek() {
        return this.stack[this.getSize() - 1];
    }
    //返回栈的长度
    getSize() {
        return this.stack.length;
    }
    // 栈的非空判断
    isEmpty() {
        return this.getSize() === 0;
    }
}

function testBracketIsValid(str) {
    // 以左右括号来建立一个对象，key为左括号，value为右括号
    var Map = {
        "{": "}",
        "(": ")",
        "[": "]",
    };
    //实例化一个栈
    const myStack = new bracketMatchStack();
    //遍历str字符串
    for (let v of str) {
        if (Map[v]) {
            myStack.push(v); //是左括号，入栈
        } else if (Object.values(Map).includes(v)) {
            // 右括号  将当前的元素和栈顶的第一个元素进行匹配
            let last = myStack.pop();
            if (v !== Map[last]) return false;
        } else {
            //这里排除的是空字符的情况，如果不是左右括号而是其他的空字符串或者非法字符的话，将终止本次循环，执行下一次循环
            continue;
        }
    }
    //遍历完成之后要保证栈内要为空
    return myStack.getSize() === 0;
}


//转换为HTML
function creactObject(text) {

    if (text.length == 1) {
        return;
    }

    //中间变量
    let Ht_type = "";
    let Ht_content = "";

    //获取的元素类型
    let ele_type = "";
    //获取的元素属性
    let ele_first = "";

    //判断text
    //段首不是指令开头和结束
    if (text.indexOf("@H") !== -1 && text.indexOf("@H") === 0) {
        const Ht_si = text.indexOf("@H");
        const Ht_ei = text.indexOf("{");

        Ht_type = text.substring(Ht_si, Ht_ei + 1);
        Ht_content = text.substring(Ht_ei + 1, text.length);

        ele_type = Ht_type.match(/(?<=@H).*?(?=\()/g);
        ele_first = Ht_type.match(/(?<=\().*?(?=\))/g);

        let classes = "";
        let c = "";

        //入栈
        stack_main.push(ele_type[0]);

        //可以增删指令
        switch (ele_type[0]) {
            case "div":
                classes = ele_first[0].replace(/\s*/g, "").split(",");
                c = `class="heti `;
                if (classes[0] !== "" && classes.length >= 1) {
                    classes.forEach((el, index) => {
                        if (index != classes.length - 1 && el !== "") {
                            c += `heti--${el} `;
                        } else if (index == classes.length - 1 && el !== "") {
                            c += `heti--${el}"`;
                        }
                    });
                } else {
                    c = ""
                }

                if (classes[0] === "" && classes.length == 1) {
                    c = ""
                }

                result += `<div ${c}>`;
                break;
            case "h2":
                result += `<h2>`;
                break;
            case "p":
                classes = ele_first[0].replace(/\s*/g, "").split(",");
                c = `class="`;

                if (classes[0] !== "" || classes.length >= 1) {
                    classes.forEach((el, index, arr) => {
                        if (index != (arr.length - 1) && el !== "") {
                            c += `heti-${el} `;
                        } else if (index == (arr.length - 1) && el !== "") {
                            c += `heti-${el}"`;
                        }
                    });
                } else {
                    c = ""
                }

                if (classes[0] === "" && classes.length == 1) {
                    c = ""
                }

                result += `<p ${c}>`;
                break;
            case "sp":
                classes = ele_first[0].replace(/\s*/g, "").split(",");
                c = `class="`;

                if (classes[0] !== "" || classes.length >= 1) {
                    classes.forEach((el, index, arr) => {
                        if (index != (arr.length - 1) && el !== "") {
                            c += `heti-${el} `;
                        } else if (index == (arr.length - 1) && el !== "") {
                            c += `heti-${el}"`;
                        }
                    });
                } else {
                    c = ""
                }

                if (classes[0] === "" && classes.length == 1) {
                    c = ""
                }

                result += `<span ${c}>`;
                break;
            case "em":
                result += `<em>`;
                break;
            case "u":
                c = `title="${ele_first[0]}"`;
                result += `<u ${c}>`;
                break;
            case "py":
                c = `${ele_first[0] ? `data-pinyin="${ele_first[0]}"` : ""}`;

                result += `<py ${c}>`;
                break;
            case "q":
                result += `<q>`;
                break;
            case "abbr":
                c = `title="${ele_first[0]}"`;
                result += `<abbr ${c}>`;
                break;
            case "mr":
                result += `<mark>`;
                break;
            case "tem":
                result += `<span class="heti-em">`;
                break;
            case "h1":
                result += `<h1>`;
                break;
            case "h3":
                result += `<h3>`;
                break;
            case "h4":
                result += `<h4>`;
                break;
            case "h5":
                result += `<h5>`;
                break;
            case "ul":
                result += `<ul>`;
                break;
            case "li":
                result += `<li>`;
                break;
            case "i":
                result += `<i>`;
                break;
            case "sup":
                result += `<sup>`;
                break;
            case "sub":
                result += `<sub>`;
                break;
            case "code":
                result += `<code>`;
                break;
            case "dfn":
                result += `<dfn>`;
                break;
            case "s":
                result += `<s>`;
                break;
            default:
                console.log(`Sorry, we are out of.`);
                break;
        }
        //处理文字开头的情况
        if (Ht_content[0] !== "@" && Ht_content[0] !== "}") {
            const Ht_si = 0;
            const isbehind = Ht_content.indexOf("@H") < Ht_content.indexOf("}");
            const Ht_ei = isbehind
                ? Ht_content.indexOf("@H")
                : Ht_content.indexOf("}");

            if (isbehind) {
                result += Ht_content.substring(Ht_si, Ht_ei);
                Ht_content = Ht_content.substring(Ht_ei, text.length);
            } else {
                result += Ht_content.substring(Ht_si, Ht_ei);
                Ht_content = Ht_content.substring(Ht_ei, text.length);
            }
        }
        creactObject(Ht_content);
    } else if (text.indexOf("@H") === -1 && text.indexOf("}") === -1) {
        return;
    } else if (text[0] !== "@" && text[0] !== "}" && text.indexOf("@H") !== -1 && text.indexOf("@H") < text.indexOf("}")) {
        const Ht_si = 0;
        const Ht_ei = text.indexOf("@H");

        result += text.substring(Ht_si, Ht_ei);
        text = text.substring(Ht_ei, text.length);
        creactObject(text);
    } else if (text[0] !== "@" && text[0] !== "}") {
        const Ht_si = 0;
        const Ht_ei = text.indexOf("}");

        result += text.substring(Ht_si, Ht_ei);
        text = text.substring(Ht_ei, text.length);
        creactObject(text);
    } else if (text.indexOf("}") == 0) {
        //遇到 } 就会有标签闭合，即栈顶元素闭合。

        text = text.substring(1, text.length);
        switch (stack_main.pop()) {
            case "div":
                result += `</div>`;
                break;
            case "h2":
                result += `</h2>`;
                break;
            case "p":
                result += `</p>`;
                break;
            case "sp":
                result += `</span>`;
                break;
            case "em":
                result += `</em>`;
                break;
            case "u":
                result += `</u>`;
                break;
            case "py":
                result += `</py>`;
                break;
            case "q":
                result += `</q>`;
                break;
            case "abbr":
                result += `</abbr>`;
                break;
            case "mr":
                result += `</mark>`;
                break;
            case "tem":
                result += `</span>`;
                break;
            case "text":
                result += ``;
                break;
            case "h1":
                result += `</h1>`;
                break;
            case "h3":
                result += `</h3>`;
                break;
            case "h4":
                result += `</h4>`;
                break;
            case "h5":
                result += `</h5>`;
                break;
            case "ul":
                result += `</ul>`;
                break;
            case "li":
                result += `</li>`;
                break;
            case "i":
                result += `</i>`;
                break;
            case "sup":
                result += `</sup>`;
                break;
            case "sub":
                result += `</sub>`;
                break;
            case "code":
                result += `</code>`;
                break;
            case "dfn":
                result += `</dfn>`;
                break;
            case "s":
                result += `</s>`;
                break;
            default:
                console.log(`Sorry, we are out of.`);
                break;
        }
        creactObject(text);
    }
}

function heti(str) {
    if (!testBracketIsValid(str)) {
        console.log("指令好像不对");
        return $("<div>指令好像不对</div>");
    }

    window.stack_main = [];
    window.result = "";

    str = str.replace(/[\n\t\s]+/g, "");
    creactObject(str);

    return $(result);
}

//遍历要作用的元素
$(".heti-box").each(function () {
    const _self = $(this);
    const _html = _self.html();
    _self.html("");
    _self.append(heti(_html));
});

//获取拼音
$("py").each(function () {
    const _self = $(this);
    const pp = _self.data("pinyin") ? _self.data("pinyin").split(",") : false;
    const str = _self.text().replace(/[^\u4E00-\u9FA5]/g, "").split("");
    _self.text("");
    str.forEach((el, index) => {
        let pinyins_str = "";
        if (pp && pp[index]) {
            pinyins_str = pp[index];
        } else {
            pinyins_str = pinyin(el);
        }
        const element = $(`<ruby><rb>${el}</rb><rp>(</rp><rt lang="zh-Latn">${pinyins_str}</rt><rp>)</rp></ruby>`);
        _self.append(element);
    })
});
```