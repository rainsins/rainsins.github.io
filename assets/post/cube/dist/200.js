"use strict";(self.webpackChunkcubing=self.webpackChunkcubing||[]).push([[200],{200:(t,e,i)=>{i.r(e),i.d(e,{Cube3D:()=>P,PG3D:()=>Y,T3I:()=>a,Twisty3DScene:()=>Z,cube3DShim:()=>_,pg3dShim:()=>K});var s=i(996),r=i(388),o=i(852),n=(i(320),i(399)),a=i(437);function c(t){return t*t*t*(10-t*(15-6*t))}var l=new a.TextureLoader,h=new a.MeshBasicMaterial({color:new a.Color(6710886).convertLinearToSRGB()}),p=new a.MeshBasicMaterial({color:new a.Color(13421772).convertLinearToSRGB(),side:a.BackSide,transparent:!0,opacity:.75}),d=new a.MeshBasicMaterial({visible:!1}),u=new a.MeshBasicMaterial({color:4513228}),f=new a.MeshBasicMaterial({color:16776618}),k=new a.MeshBasicMaterial({color:4513228,side:a.BackSide,transparent:!0,opacity:.5}),m=new a.MeshBasicMaterial({color:16775545,side:a.BackSide,transparent:!0,opacity:.5}),S=class{constructor(t,e,i,s,r,o){this.vector=t,this.fromZ=e,this.color=i,this.dimColor=s,this.hintOpacityScale=r;const n=new a.Color(i).convertLinearToSRGB(),c=new a.Color(s).convertLinearToSRGB();this.stickerMaterial={regular:new a.MeshBasicMaterial({color:n,side:a.FrontSide}),dim:new a.MeshBasicMaterial({color:c,side:a.FrontSide}),oriented:u,experimentalOriented2:f,ignored:h,invisible:d},this.hintStickerMaterial={regular:new a.MeshBasicMaterial({color:new a.Color(o?.hintColor??i).convertLinearToSRGB(),side:a.BackSide,transparent:!0,opacity:.5*r}),dim:new a.MeshBasicMaterial({color:new a.Color(o?.hintDimColor??s).convertLinearToSRGB(),side:a.BackSide,transparent:!0,opacity:.5*r}),oriented:k,experimentalOriented2:m,ignored:p,invisible:d}}stickerMaterial;hintStickerMaterial},w=[new S(new a.Vector3(0,1,0),new a.Euler(-s.DD/4,0,0),16777215,14540253,1.25),new S(new a.Vector3(-1,0,0),new a.Euler(0,-s.DD/4,0),16750848,8934656,1,{hintDimColor:8930304}),new S(new a.Vector3(0,0,1),new a.Euler(0,0,0),65280,34816,1,{hintDimColor:39168}),new S(new a.Vector3(1,0,0),new a.Euler(0,s.DD/4,0),16711680,6684672,1,{hintDimColor:6684672}),new S(new a.Vector3(0,0,-1),new a.Euler(0,s.DD/2,0),2254591,1127304,.75,{hintDimColor:6246}),new S(new a.Vector3(0,-1,0),new a.Euler(s.DD/4,0,0),16776960,8947712,1.25,{hintDimColor:14540032})],M={U:0,L:1,F:2,R:3,B:4,D:5},g={U:M.U,u:M.U,Uw:M.U,Uv:M.U,y:M.U,L:M.L,l:M.L,Lw:M.L,Lv:M.L,M:M.L,F:M.F,f:M.F,Fw:M.F,Fv:M.F,S:M.F,z:M.F,R:M.R,r:M.R,Rw:M.R,Rv:M.R,x:M.R,B:M.B,b:M.B,Bw:M.B,Bv:M.B,D:M.D,d:M.D,Dw:M.D,Dv:M.D,E:M.D},y={showMainStickers:!0,hintFacelets:"floating",showFoundation:!0,experimentalStickeringMask:void 0,foundationSprite:null,hintSprite:null,initialHintFaceletsAnimation:"auto",faceletScale:"auto"};function D(t){return void 0===t.faceletScale||"auto"===t.faceletScale?.85:t.faceletScale}var v=new a.MeshBasicMaterial({color:0,opacity:1,transparent:!0}),x=new a.MeshBasicMaterial({color:0,opacity:.3,transparent:!0}),b=class{constructor(t,e,i){this.orbit=t;const s="string"==typeof e?e.split(""):e;this.stickerFaces=s.map((t=>M[t])),this.matrix=new a.Matrix4,this.matrix.setPosition(F[t]),this.matrix.premultiply((new a.Matrix4).makeRotationFromQuaternion(i))}matrix;stickerFaces};function E(t,e){return(new a.Quaternion).setFromAxisAngle(t,s.DD*e/4)}var R={O:new a.Vector3(0,0,0),U:new a.Vector3(0,-1,0),L:new a.Vector3(1,0,0),F:new a.Vector3(0,0,-1),R:new a.Vector3(-1,0,0),B:new a.Vector3(0,0,1),D:new a.Vector3(0,1,0)},F={EDGES:new a.Vector3(0,1,1),CORNERS:new a.Vector3(1,1,1),CENTERS:new a.Vector3(0,1,0)},C={EDGES:[0,1].map((t=>(new a.Matrix4).makeRotationAxis(F.EDGES.clone().normalize(),-t*s.DD/2))),CORNERS:[0,1,2].map((t=>(new a.Matrix4).makeRotationAxis(F.CORNERS.clone().normalize(),-t*s.DD/3))),CENTERS:[0,1,2,3].map((t=>(new a.Matrix4).makeRotationAxis(F.CENTERS.clone().normalize(),-t*s.DD/4)))},B=[M.U,M.F,M.R],A={EDGES:[new b("EDGES","UF",E(R.O,0)),new b("EDGES","UR",E(R.U,3)),new b("EDGES","UB",E(R.U,2)),new b("EDGES","UL",E(R.U,1)),new b("EDGES","DF",E(R.F,2)),new b("EDGES","DR",E(R.F,2).premultiply(E(R.D,1))),new b("EDGES","DB",E(R.F,2).premultiply(E(R.D,2))),new b("EDGES","DL",E(R.F,2).premultiply(E(R.D,3))),new b("EDGES","FR",E(R.U,3).premultiply(E(R.R,3))),new b("EDGES","FL",E(R.U,1).premultiply(E(R.R,3))),new b("EDGES","BR",E(R.U,3).premultiply(E(R.R,1))),new b("EDGES","BL",E(R.U,1).premultiply(E(R.R,1)))],CORNERS:[new b("CORNERS","UFR",E(R.O,0)),new b("CORNERS","URB",E(R.U,3)),new b("CORNERS","UBL",E(R.U,2)),new b("CORNERS","ULF",E(R.U,1)),new b("CORNERS","DRF",E(R.F,2).premultiply(E(R.D,1))),new b("CORNERS","DFL",E(R.F,2).premultiply(E(R.D,0))),new b("CORNERS","DLB",E(R.F,2).premultiply(E(R.D,3))),new b("CORNERS","DBR",E(R.F,2).premultiply(E(R.D,2)))],CENTERS:[new b("CENTERS","U",E(R.O,0)),new b("CENTERS","L",E(R.R,3).premultiply(E(R.U,1))),new b("CENTERS","F",E(R.R,3)),new b("CENTERS","R",E(R.R,3).premultiply(E(R.D,1))),new b("CENTERS","B",E(R.R,3).premultiply(E(R.D,2))),new b("CENTERS","D",E(R.R,2))]},U=1/3,T={EDGES:[[[0,4,6],[0,4,5]],[[3,5,7],[0,7,5]],[[2,4,8],[0,10,5]],[[1,3,7],[0,1,5]],[[2,4,2],[2,4,3]],[[3,5,1],[2,7,3]],[[0,4,0],[2,10,3]],[[1,3,1],[2,1,3]],[[3,5,4],[3,6,4]],[[1,3,4],[1,2,4]],[[1,9,4],[1,8,4]],[[3,11,4],[3,0,4]]],CORNERS:[[[0,5,6],[0,5,5],[0,6,5]],[[3,5,8],[0,8,5],[0,9,5]],[[2,3,8],[0,11,5],[0,0,5]],[[1,3,6],[0,2,5],[0,3,5]],[[3,5,2],[2,6,3],[2,5,3]],[[2,3,2],[2,3,3],[2,2,3]],[[1,3,0],[2,0,3],[2,11,3]],[[0,5,0],[2,9,3],[2,8,3]]],CENTERS:[[[0,4,7]],[[0,1,4]],[[0,4,4]],[[0,7,4]],[[0,10,4]],[[0,4,1]]]},z=null;function G(){const t=new a.BufferGeometry,e=.5;return t.setAttribute("position",new a.BufferAttribute(new Float32Array([e,e,0,-.5,e,0,e,-.5,0,-.5,e,0,-.5,-.5,0,e,-.5,0]),3)),t.setAttribute("uv",new a.BufferAttribute(new Float32Array([1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,1,1]),2)),t}var O=null,P=class extends a.Object3D{constructor(t,e,i={}){if(super(),this.kpuzzle=t,this.scheduleRenderCallback=e,this.options={...y},Object.assign(this.options,i),"3x3x3"!==this.kpuzzle.name())throw new Error(`Invalid puzzle for this Cube3D implementation: ${this.kpuzzle.name()}`);i.foundationSprite&&this.setSprite(i.foundationSprite),i.hintSprite&&this.setHintSprite(i.hintSprite),this.kpuzzleFaceletInfo={};for(const t in A){const e=[];this.kpuzzleFaceletInfo[t]=e,this.pieces[t]=A[t].map(this.createCubie.bind(this,t,e))}this.scale.set(U,U,U),this.options.experimentalStickeringMask&&this.setStickeringMask(this.options.experimentalStickeringMask),this.#t(),this.options.faceletScale&&this.experimentalSetFaceletScale(this.options.faceletScale)}kpuzzleFaceletInfo;pieces={};options;experimentalHintStickerMeshes=[];experimentalFoundationMeshes=[];setSpriteURL;sprite=new Promise((t=>{this.setSpriteURL=e=>{l.load(e,t)}}));setSprite(t){this.sprite=t}setHintSpriteURL;hintSprite=new Promise((t=>{this.setHintSpriteURL=e=>{l.load(e,t)}}));setHintSprite(t){this.hintSprite=t}#e=null;#i(){return this.#e??=G()}#t(){if("none"===this.options.initialHintFaceletsAnimation||"always"!==this.options.initialHintFaceletsAnimation&&(0,s.qC)())return;this.#i().translate(0,0,-.947),setTimeout((()=>{const t=performance.now();let e=0;const i=()=>{const s=performance.now()-t,r=(o=s/1e3)*(2-o)*.947;var o;this.#i().translate(0,0,r-e),e=r,s<1e3&&(requestAnimationFrame(i),this.scheduleRenderCallback?.())};i()}),500)}experimentalSetStickerSpriteURL(t){this.setSpriteURL(t)}experimentalSetHintStickerSpriteURL(t){this.setHintSpriteURL(t)}setStickeringMask(t){if("picture"!==t.specialBehaviour){this.options.experimentalStickeringMask=t;for(const[e,i]of Object.entries(t.orbits))for(let t=0;t<i.pieces.length;t++){const s=i.pieces[t];if(s){const i=this.kpuzzleFaceletInfo[e][t];for(let t=0;t<i.length;t++){const e=s.facelets[t];if(e){const s=i[t],r="string"==typeof e?e:e?.mask;s.facelet.material=w[s.faceIdx].stickerMaterial[r];const o="string"==typeof e?r:e.hintMask??r;s.hintFacelet&&(s.hintFacelet.material=w[s.faceIdx].hintStickerMaterial[o])}}}}this.scheduleRenderCallback&&this.scheduleRenderCallback()}else for(const t of Object.values(this.kpuzzleFaceletInfo))for(const e of t)for(const t of e){t.facelet.material=d;const{hintFacelet:e}=t;e&&(e.material=d)}}experimentalUpdateOptions(t){if("showMainStickers"in t)throw new Error("Unimplemented");const e=t.showFoundation;if(void 0!==e&&this.options.showFoundation!==e){this.options.showFoundation=e;for(const t of this.experimentalFoundationMeshes)t.visible=e}const i=t.hintFacelets;if(void 0!==i&&this.options.hintFacelets!==i&&s.yu[i]){this.options.hintFacelets=i;for(const t of this.experimentalHintStickerMeshes)t.visible="floating"===i;this.scheduleRenderCallback()}const{experimentalStickeringMask:r}=t;void 0!==r&&(this.options.experimentalStickeringMask=r,this.setStickeringMask(r),this.scheduleRenderCallback());const{faceletScale:o}=t;void 0!==o&&this.experimentalSetFaceletScale(o)}onPositionChange(t){const e=t.pattern;for(const i in A){const r=A[i];for(let t=0;t<r.length;t++){const s=e.patternData[i].pieces[t];this.pieces[i][s].matrix.copy(A[i][t].matrix),this.pieces[i][s].matrix.multiply(C[i][e.patternData[i].orientation[t]])}for(const o of t.movesInProgress){const t=o.move,n=w[g[t.family]].vector,c=(new a.Matrix4).makeRotationAxis(n,-this.ease(o.fraction)*o.direction*t.amount*s.DD/4);for(let s=0;s<r.length;s++){const r=this.kpuzzle.moveToTransformation(t.modified({amount:1}));if(s!==r.transformationData[i].permutation[s]||0!==r.transformationData[i].orientationDelta[s]){const t=e.patternData[i].pieces[s];this.pieces[i][t].matrix.premultiply(c)}}}}this.scheduleRenderCallback()}createCubie(t,e,i,s){const r=[];e.push(r);const o=new a.Group;if(this.options.showFoundation){const t=this.createCubieFoundation();o.add(t),this.experimentalFoundationMeshes.push(t)}for(let e=0;e<i.stickerFaces.length;e++){const n=this.createSticker(w[B[e]],w[i.stickerFaces[e]],!1),c={faceIdx:i.stickerFaces[e],facelet:n};if(o.add(n),"floating"===this.options.hintFacelets){const t=this.createSticker(w[B[e]],w[i.stickerFaces[e]],!0);o.add(t),c.hintFacelet=t,this.experimentalHintStickerMeshes.push(t)}if("picture"===this.options.experimentalStickeringMask?.specialBehaviour&&T[t]&&T[t][s]&&T[t][s][e]){const[r,n,c]=T[t][s][e];(async()=>{const t=async t=>{const s=await(t?this.hintSprite:this.sprite),l=this.createSticker(w[B[e]],w[i.stickerFaces[e]],t);l.material=new a.MeshBasicMaterial({map:s,side:t?a.BackSide:a.DoubleSide,transparent:!0});const h=n/12,p=(n+1)/12,d=c/9,u=(c+1)/9;let f=new a.Vector2(h,d),k=new a.Vector2(h,u),m=new a.Vector2(p,u),S=new a.Vector2(p,d);switch(r){case 1:[f,k,m,S]=[k,m,S,f];break;case 2:[f,k,m,S]=[m,S,f,k];break;case 3:[f,k,m,S]=[S,f,k,m]}l.geometry.setAttribute("uv",new a.BufferAttribute(new Float32Array([m.x,m.y,k.x,k.y,S.x,S.y,k.x,k.y,f.x,f.y,S.x,S.y]),2)),o.add(l)};t(!0),t(!1)})()}r.push(c)}return o.matrix.copy(i.matrix),o.matrixAutoUpdate=!1,this.add(o),o}createCubieFoundation(){const t=z??(z=new a.BoxGeometry(1,1,1));return new a.Mesh(t,"picture"===this.options.experimentalStickeringMask?.specialBehaviour?v:x)}createSticker(t,e,i){const s="picture"===this.options.experimentalStickeringMask?.specialBehaviour?G():i?this.#i():O??(O=G()),r=new a.Mesh(s,i?e.hintStickerMaterial.regular:e.stickerMaterial.regular);return r.setRotationFromEuler(t.fromZ),r.position.copy(t.vector),r.position.multiplyScalar(i?"picture"===this.options.experimentalStickeringMask?.specialBehaviour?2:1.45:.503),r.scale.setScalar(D(this.options)),r}experimentalSetFoundationOpacity(t){this.experimentalFoundationMeshes[0].material.opacity=t}experimentalSetFaceletScale(t){this.options.faceletScale=t;for(const t of Object.values(this.kpuzzleFaceletInfo))for(const e of t)for(const t of e)t.facelet.scale.setScalar(D(this.options)),t.hintFacelet?.scale.setScalar(D(this.options))}ease(t){return c(t)}},H=new a.MeshBasicMaterial({side:a.DoubleSide,color:0}),L=new a.MeshBasicMaterial({visible:!1}),N=new a.MeshBasicMaterial({vertexColors:!0});function V(t,e,i){return Math.hypot(t[3*e]-t[3*i],t[3*e+1]-t[3*i+1],t[3*e+2]-t[3*i+2])}function I(t,e,i,s){const r=V(t,e,i),o=V(t,i,s),n=V(t,e,s),a=(r+o+n)/2;return Math.sqrt(a*(a-r)*(a-o)*(a-n))}function j(t){let e=0;for(let i=2;3*i<t.length;i++)e+=I(t,0,1,i);return e}var q=class{constructor(t,e){this.sz=t,this.tm=e,this.vertices=new Float32Array(9*t),this.uvs=void 0,this.colors=new Uint8Array(18*t),this.ind=new Uint8Array(t),this.pos=0,this.ipos=0}pos;ipos;vertices;colors;uvs;ind;add(t,e,i){this.vertices[this.pos]=t[3*e+0],this.vertices[this.pos+1]=t[3*e+1],this.vertices[this.pos+2]=t[3*e+2],this.colors[this.pos]=i>>16,this.colors[this.pos+1]=i>>8&255,this.colors[this.pos+2]=255&i,this.pos+=3}addUncolored(t,e){this.vertices[this.pos]=t[3*e+0],this.vertices[this.pos+1]=t[3*e+1],this.vertices[this.pos+2]=t[3*e+2],this.pos+=3}setind(t){this.ind[this.ipos++]=t}makePoly(t,e,i){const s=t;for(let t=1;3*(t+1)<s.length;t++)this.add(s,0,e),this.add(s,t,e),this.add(s,t+1,e),this.setind(i)}setAttributes(t){t.setAttribute("position",new a.BufferAttribute(this.vertices,3));const e=this.colors.subarray(0,9*this.sz);t.setAttribute("color",new a.BufferAttribute(e,3,!0))}makeGroups(t){t.clearGroups();for(let e=0;e<this.ipos;){const i=e++,s=this.ind[i];for(;this.ind[e]===s;)e++;t.addGroup(3*i,3*(e-i),s)}}saveOriginalColors(){this.colors.copyWithin(this.pos,0,this.pos)}},W=class{origColor;origColorStickeringMask;faceColor;texturePtr=void 0;twistVal=-1;stickerStart;stickerEnd;hintStart;hintEnd;foundationStart;foundationEnd;isDup;faceNum;constructor(t,e,i,s){this.isDup=!!e.isDup,this.faceNum=e.face,this.stickerStart=t.ipos;const r=new a.Color(e.color).getHex();this.origColor=r,this.origColorStickeringMask=r,s?.stickeringMask&&this.setStickeringMask(t,s.stickeringMask),this.faceColor=r;const o=this.stickerCoords(e.coords,i);t.makePoly(o,this.faceColor,this.isDup?4:0),this.stickerEnd=t.ipos}stickerCoords(t,e){return function(t,e){const i=[],s=new Array(3),r=new Array(3);for(let o=1;o<10;o++){for(let o=0;o<t.length;o+=3){const n=(o+t.length-3)%t.length,a=(o+3)%t.length;for(let e=0;e<3;e++)s[e]=t[n+e]-t[o+e],r[e]=t[a+e]-t[o+e];const c=Math.hypot(s[0],s[1],s[2]),l=Math.hypot(r[0],r[1],r[2]);for(let t=0;t<3;t++)s[t]/=c,r[t]/=l;const h=s[0]*r[0]+s[1]*r[1]+s[2]*r[2],p=e/Math.sqrt(1-h*h);for(let e=0;e<3;e++)i[o+e]=t[o+e]+(s[e]+r[e])*p}let o=!0;for(let e=0;o&&e<i.length;e+=3){const s=(e+3)%t.length;let r=0;for(let o=0;o<3;o++)r+=(t[s+o]-t[e+o])*(i[s+o]-i[e+o]);r<=0&&(o=!1)}if(o)return i;e/=2}return t}(t.slice(),e)}hintCoords(t,e,i,s){t=this.stickerCoords(t,i),s=s.slice();for(let t=0;t<3;t++)s[t]*=.5*e;const r=new Array(t.length);for(let e=0;3*e<t.length;e++){const i=t.length/3-1-e;r[3*e]=t[3*i]+s[0],r[3*e+1]=t[3*i+1]+s[1],r[3*e+2]=t[3*i+2]+s[2]}return r}foundationCoords(t){const e=t.slice();for(let i=0;i<t.length;i++)e[i]=.999*t[i];return e}addHint(t,e,i,s,r,o){this.hintStart=t.ipos;const n=this.hintCoords(e.coords,s,r,o);t.makePoly(n,this.faceColor,i&&!this.isDup?2:4),this.hintEnd=t.ipos}addFoundation(t,e,i){this.foundationStart=t.ipos;const s=this.foundationCoords(e.coords);t.makePoly(s,i,this.isDup?4:6),this.foundationEnd=t.ipos}setHintStickers(t,e){const i=this.isDup||!e?4:2;for(let e=this.hintStart;e<this.hintEnd;e++)t.ind[e]=i|1&t.ind[e]}setStickeringMask(t,e){let i=0;switch(e){case"regular":case"invisible":i=this.origColor;break;case"dim":i=16777215===this.origColor?14540253:new a.Color(this.origColor).multiplyScalar(.5).getHex();break;case"oriented":i=16746751;break;case"ignored":i=4473924}this.origColorStickeringMask=i;for(let e=9*this.stickerStart;e<9*this.stickerEnd;e+=3)t.colors[t.pos+e]=i>>16,t.colors[t.pos+e+1]=i>>8&255,t.colors[t.pos+e+2]=255&i;for(let e=9*this.hintStart;e<9*this.hintEnd;e+=3)t.colors[t.pos+e]=i>>16,t.colors[t.pos+e+1]=i>>8&255,t.colors[t.pos+e+2]=255&i;this.setHintStickers(t,"invisible"!==e&&!this.isDup)}addUVs(t){const e=t.uvs,i=t.vertices,s=new Array(3);for(let r=3*this.stickerStart;r<3*this.stickerEnd;r++){s[0]=i[3*r],s[1]=i[3*r+1],s[2]=i[3*r+2];const o=t.tm.getuv(this.faceNum,s);e[2*r]=o[0],e[2*r+1]=o[1]}for(let r=3*this.hintStart;r<3*this.hintEnd;r++){s[0]=i[3*r],s[1]=i[3*r+1],s[2]=i[3*r+2];const o=t.tm.getuv(this.faceNum,s);e[2*r]=o[0],e[2*r+1]=o[1]}}setTexture(t,e){if(this.texturePtr===e)return 0;this.texturePtr=e;const i=6*t.sz;return t.uvs.copyWithin(6*this.stickerStart,6*e.stickerStart+i,6*e.stickerEnd+i),t.uvs.copyWithin(6*this.hintStart,6*e.hintStart+i,6*e.hintEnd+i),1}setColor(t,e){const i=e.origColorStickeringMask;if(this.faceColor!==i){this.faceColor=i;const s=t.pos;return t.colors.copyWithin(9*this.stickerStart,9*e.stickerStart+s,9*e.stickerEnd+s),t.colors.copyWithin(9*this.hintStart,9*e.hintStart+s,9*e.hintEnd+s),1}return 0}},J=class{cubie;geo;constructor(t,e,i){this.cubie=new a.Group;const s=t.coords,r=new q(s.length/3-2,e);for(let t=1;3*t+3<s.length;t++)r.addUncolored(s,0),r.addUncolored(s,t),r.addUncolored(s,t+1);this.geo=new a.BufferGeometry,r.setAttributes(this.geo);const o=new a.Mesh(this.geo,L);o.userData.quantumMove=i.notationMapper.notationToExternal(new n.yU(t.name)),this.cubie.scale.setScalar(.99),this.cubie.add(o)}},$=class{axis;order;constructor(t){const e=t.coordinates;this.axis=new a.Vector3(e[0],e[1],e[2]),this.order=t.order}},Q=.5,Y=class extends a.Object3D{constructor(t,e,i,s=!1,r=!1,n=1,c=1,l={}){if(super(),this.scheduleRenderCallback=t,this.kpuzzle=e,this.stickerDat=i,this.faceletScale=c,this.params=l,0===i.stickers.length)throw Error("Reuse of stickerdat from pg; please don't do that.");this.hintMaterial=new a.MeshBasicMaterial({vertexColors:!0,transparent:!0,opacity:.5}),this.hintMaterialDisposable=!0,this.stickerMaterial=N,this.stickerMaterialDisposable=!1,this.axesInfo={};const h=this.stickerDat.axis;for(const t of h)this.axesInfo[t.quantumMove.family]=new $(t);const p=this.stickerDat.stickers;this.stickers={},this.materialArray1=new Array(8),this.materialArray2=new Array(8),this.showFoundation(s),s=!0;let d=0;for(const t of p)d+=3*(t.coords.length/3-2);const u=new q(d,i.textureMapper),f=[];let k=0;for(const t of i.faces)f.push(function(t){const e=Math.hypot(t[0],t[1],t[2]);return t[0]/=e,t[1]/=e,t[2]/=e,t}(function(t,e){const i=new Array(3);return i[0]=t[1]*e[2]-t[2]*e[1],i[1]=t[2]*e[0]-t[0]*e[2],i[2]=t[0]*e[1]-t[1]*e[0],i}([(m=t.coords)[3]-m[0],m[4]-m[1],m[5]-m[2]],[m[6]-m[3],m[7]-m[4],m[8]-m[5]]))),k+=j(t.coords);var m;const S="auto"!==c?c*c:.71;let w=0;for(const t of p)t.isDup||w++;const M=Math.sqrt(k/w)*(1-Math.sqrt(S))/2;for(const t of p){const e=t.orbit,i=t.ord,s=t.ori;this.stickers[e]||(this.stickers[e]=[]),this.stickers[e][s]||(this.stickers[e][s]=[]);const r={};l.stickeringMask&&(r.stickeringMask=(0,o.Y)(l.stickeringMask,e,i,s,!1));const n=new W(u,t,M,r);this.stickers[e][s][i]=n}this.showHintStickers=r,r=!0;for(const t of p){const e=t.orbit,i=t.ord,s=t.ori;this.stickers[e][s][i].addHint(u,t,r,n,M,f[t.face])}this.foundationBound=u.ipos;for(const t of p){const e=t.orbit,i=t.ord,r=t.ori;s&&this.stickers[e][r][i].addFoundation(u,t,0)}const g=new a.BufferGeometry;u.setAttributes(g),u.makeGroups(g);const y=new a.Mesh(g,this.materialArray1);y.scale.set(Q,Q,Q),this.add(y);const D=new a.Mesh(g,this.materialArray2);D.scale.set(Q,Q,Q),this.add(D);const v=this.stickerDat.faces;this.movingObj=D,this.fixedGeo=g,this.filler=u;for(const t of v){const e=new J(t,i.textureMapper,this.stickerDat);e.cubie.scale.set(Q,Q,Q),this.add(e.cubie),this.controlTargets.push(e.cubie.children[0])}u.saveOriginalColors(),i.stickers=[],this.updateMaterialArrays()}stickers;axesInfo;stickerTargets=[];controlTargets=[];movingObj;filler;foundationBound;fixedGeo;lastPos;lastMoveTransformation;hintMaterial;stickerMaterial;materialArray1;materialArray2;textured=!1;showHintStickers=!1;showFoundations=!1;hintMaterialDisposable;stickerMaterialDisposable;#s=!1;isPG3DForTwisty3DPuzzleWrapper;dispose(){this.fixedGeo&&this.fixedGeo.dispose(),this.stickerMaterialDisposable&&(this.stickerMaterial.dispose(),this.stickerMaterial=N,this.stickerMaterialDisposable=!1),this.hintMaterialDisposable&&(this.hintMaterial.dispose(),this.hintMaterial=N,this.hintMaterialDisposable=!1)}experimentalGetStickerTargets(){return this.stickerTargets}experimentalGetControlTargets(){return this.controlTargets}#r(t){try{return this.kpuzzle.moveToTransformation(t),!0}catch(t){return!1}}getClosestMoveToAxis(t,e){let i=null,s=0,r=t=>t;switch(e.depth){case"secondSlice":r=t=>t.modified({innerLayer:2});break;case"rotation":r=t=>t.modified({family:`${t.family}v`})}for(const e of this.stickerDat.axis){const o=t.dot(new a.Vector3(...e.coordinates));if(o>s){const t=this.stickerDat.notationMapper.notationToExternal(r(e.quantumMove));if(!t)continue;this.#r(t)&&(s=o,i=t)}}return i?(e.invert&&(i=i.invert()),{move:i,order:this.kpuzzle.moveToTransformation(i).repetitionOrder()}):null}setStickeringMask(t){if(this.params.stickeringMask=t,"picture"!==t.specialBehaviour)for(const e of this.kpuzzle.definition.orbits){const{numPieces:i,numOrientations:s}=e;for(let r=0;r<i;r++)for(let i=0;i<s;i++){const s=(0,o.Y)(t,e.orbitName,r,i,!1),n=this.stickers[e.orbitName][i][r];this.textured&&this.hintMaterialDisposable&&"invisible"===s||n.setStickeringMask(this.filler,s)}}this.#s=!0,this.lastPos&&this.onPositionChange(this.lastPos)}onPositionChange(t){const e=t.pattern.experimentalToTransformation();if(!e)throw new Error("indistinguishable pieces are not supported by PG3D yet");const i=new a.Euler;this.movingObj.rotation.copy(i);let r=0;const o=this.filler,n=o.ind;if(!this.lastPos||this.#s||!this.lastPos.pattern.experimentalToTransformation().isIdentical(e)){for(const t in this.stickers){const i=this.stickers[t],s=e.transformationData[t],n=i.length;if(1===n){const t=i[0];for(let e=0;e<t.length;e++){const i=s.permutation[e];this.textured?r+=t[e].setTexture(o,t[i]):r+=t[e].setColor(o,t[i])}}else for(let t=0;t<n;t++){const e=i[t];for(let a=0;a<e.length;a++){const c=(t+n-s.orientationDelta[a])%n,l=s.permutation[a];this.textured?r+=e[a].setTexture(o,i[c][l]):r+=e[a].setColor(o,i[c][l])}}}this.lastPos=t}let c=0;for(const e of t.movesInProgress){const t=e.move,i=this.stickerDat.unswizzle(t);if(!i)return;const r=t;let o;try{o=this.kpuzzle.moveToTransformation(r.modified({amount:1}))}catch(t){const e=this.stickerDat.notationMapper.notationToInternal(r);if(e){const t=this.stickerDat.notationMapper.notationToExternal(e.modified({amount:1}));t&&(o=this.kpuzzle.moveToTransformation(t))}if(!o)throw console.log(t),t}const a=this.axesInfo[i.family],l=a.axis,h=-this.ease(e.fraction)*e.direction*i.amount*s.DD/a.order;if(this.movingObj.rotateOnAxis(l,h),this.lastMoveTransformation!==o){for(const t in this.stickers){const e=this.stickers[t],i=e.length,s=o.transformationData[t];for(let t=0;t<i;t++){const i=e[t];for(let t=0;t<i.length;t++){const e=i[t];let r=0;if(s.permutation[t]===t&&0===s.orientationDelta[t]||(r=1),r!==e.twistVal){if(r){for(let t=e.stickerStart;t<e.stickerEnd;t++)n[t]|=1;for(let t=e.hintStart;t<e.hintEnd;t++)n[t]|=1;for(let t=e.foundationStart;t<e.foundationEnd;t++)n[t]|=1}else{for(let t=e.stickerStart;t<e.stickerEnd;t++)n[t]&=-2;for(let t=e.hintStart;t<e.hintEnd;t++)n[t]&=-2;for(let t=e.foundationStart;t<e.foundationEnd;t++)n[t]&=-2}e.twistVal=r,c++}}}}this.lastMoveTransformation=o}}(this.#s||c)&&this.filler.makeGroups(this.fixedGeo),(this.#s||r)&&(this.textured&&(this.fixedGeo.getAttribute("uv").addUpdateRange(0,6*this.foundationBound),this.fixedGeo.getAttribute("uv").needsUpdate=!0),!this.#s&&this.textured||(this.fixedGeo.getAttribute("color").addUpdateRange(0,9*this.foundationBound),this.fixedGeo.getAttribute("color").needsUpdate=!0)),this.scheduleRenderCallback(),this.#s=!1}ease(t){return c(t)}showHintFacelets(t){this.showHintStickers=t}updateMaterialArrays(){for(let t=0;t<8;t++)this.materialArray1[t]=L,this.materialArray2[t]=L;this.materialArray1[0]=this.stickerMaterial,this.materialArray2[1]=this.stickerMaterial,this.showHintStickers?(this.materialArray1[2]=this.hintMaterial,this.materialArray2[3]=this.hintMaterial):(this.materialArray1[2]=L,this.materialArray2[3]=L),this.showFoundations?(this.materialArray1[6]=H,this.materialArray2[7]=H):(this.materialArray1[6]=L,this.materialArray2[7]=L)}showFoundation(t){this.showFoundations=t}setHintStickerOpacity(t){this.hintMaterialDisposable&&(this.hintMaterial.dispose(),this.hintMaterialDisposable=!1),0===t?this.hintMaterial=L:1===t?this.hintMaterial=this.stickerMaterial:(this.hintMaterial=new a.MeshBasicMaterial({vertexColors:!0,transparent:!0,opacity:t}),this.hintMaterialDisposable=!0)}experimentalUpdateOptions(t){void 0!==t.hintFacelets&&this.showHintFacelets("none"!==t.hintFacelets),void 0!==t.showFoundation&&this.showFoundation(t.showFoundation),void 0!==t.hintStickerOpacity&&this.setHintStickerOpacity(t.hintStickerOpacity),this.#s=!0,this.lastPos&&this.onPositionChange(this.lastPos),void 0!==t.faceletScale&&t.faceletScale!==this.faceletScale&&console.warn("Dynamic facelet scale is not yet supported for PG3D. For now, re-create the TwistyPlayer to change the facelet scale."),this.updateMaterialArrays(),this.scheduleRenderCallback()}adduvs(){const t=this.filler;if(t.uvs)return;this.filler.uvs=new Float32Array(12*t.sz);for(const t in this.stickers){const e=this.stickers[t],i=e.length;for(let t=0;t<i;t++){const i=e[t];for(const t of i)t.addUVs(this.filler)}}t.uvs.copyWithin(6*t.sz,0,6*t.sz);const e=t.uvs.subarray(0,6*t.sz);this.fixedGeo.setAttribute("uv",new a.BufferAttribute(e,2,!0))}experimentalUpdateTexture(t,e,i){e||(t=!1),t&&!this.filler.uvs&&this.adduvs(),this.textured=t,this.stickerMaterialDisposable&&(this.stickerMaterial.dispose(),this.stickerMaterialDisposable=!1),t?(this.stickerMaterial=new a.MeshBasicMaterial({map:e,side:a.FrontSide,transparent:!1}),this.stickerMaterialDisposable=!0):this.stickerMaterial=N,this.hintMaterialDisposable&&(this.hintMaterial.dispose(),this.hintMaterialDisposable=!1),t?(this.hintMaterial=new a.MeshBasicMaterial({map:i,side:a.FrontSide,transparent:!0}),this.hintMaterialDisposable=!0):this.hintMaterial=N,t&&this.showHintFacelets(null!==i),this.updateMaterialArrays(),this.#s=!0,this.lastPos&&this.onPositionChange(this.lastPos),this.scheduleRenderCallback()}},Z=class{renderTargets=new Set;twisty3Ds=new Set;threeJSScene=(async()=>new(await s.u_).Scene)();addRenderTarget(t){this.renderTargets.add(t)}scheduleRender(){for(const t of this.renderTargets)t.scheduleRender()}async addTwisty3DPuzzle(t){this.twisty3Ds.add(t),(await this.threeJSScene).add(t)}async removeTwisty3DPuzzle(t){this.twisty3Ds.delete(t),(await this.threeJSScene).remove(t)}async clearPuzzles(){for(const t of this.twisty3Ds)(await this.threeJSScene).remove(t);this.twisty3Ds.clear()}};async function _(t,e){return new P(await r.P$.kpuzzle(),t,e)}async function K(t,e,i,s,r){return new Y(t,await e.kpuzzle(),(await e.pg()).get3d({darkIgnoredOrbits:r}),!0,"floating"===i,void 0,s)}}}]);