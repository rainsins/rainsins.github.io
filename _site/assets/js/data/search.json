[
  
  {
    "title": "绝佳的学习视频：2014年丹麦公开赛林丹VS周天成低视角高清录像",
    "url": "/posts/lindan/",
    "categories": "羽毛球",
    "tags": "羽毛球",
    "date": "2024-04-04 16:32:10 +0800",
    





    
    "snippet": "    全场高清录像下载链接：夸克网盘 、One Drive(密码：lindan66)、Google Drive、自己的服务(IPv6)。        右手打球的可以镜像视频进行学习：显示设置 -&gt; 画面翻转 -&gt; 水平。我的Safari浏览器无法播放，Chrome和火狐可以，移动端大概率无法播放。        剪辑视频来自up: mcwawa。  剪辑录像",
    "content": "    全场高清录像下载链接：夸克网盘 、One Drive(密码：lindan66)、Google Drive、自己的服务(IPv6)。        右手打球的可以镜像视频进行学习：显示设置 -&gt; 画面翻转 -&gt; 水平。我的Safari浏览器无法播放，Chrome和火狐可以，移动端大概率无法播放。        剪辑视频来自up: mcwawa。  剪辑录像"
  },
  
  {
    "title": "一个趋于完美的黑苹果EFI文件",
    "url": "/posts/mac/",
    "categories": "黑苹果",
    "tags": "EFI",
    "date": "2024-03-14 16:32:10 +0800",
    





    
    "snippet": "前言    随着苹果推进自家CPU的发展，对Intel的CPU支持也将结束，现在的MacOS Snonma也许是最后一个支持Intel的版本，且用且珍惜。      这个主机兜兜转转试过了好多的系统，除了MacOS和Windows11一直都在用之外，还试过如Deepin、优麒麟、银河麒麟、开放麒麟、Ubuntu、ChromeOS、FydeOS、Zorin，以及现在正在用的统信UOS。    ...",
    "content": "前言    随着苹果推进自家CPU的发展，对Intel的CPU支持也将结束，现在的MacOS Snonma也许是最后一个支持Intel的版本，且用且珍惜。      这个主机兜兜转转试过了好多的系统，除了MacOS和Windows11一直都在用之外，还试过如Deepin、优麒麟、银河麒麟、开放麒麟、Ubuntu、ChromeOS、FydeOS、Zorin，以及现在正在用的统信UOS。      如何使用Opencore引导MacOS、Windows11、Linux三个系统，请看这篇使用Opencore引导多个系统。  配置            项目      名称      备注                  处理器      Intel Core I5-9600KF      420              主板      微星 Z390M-S01      220              显卡      蓝宝石 RX570 4G      200              内存      芝奇幻光戟 3600C18 16G✖️2      320              Mac主硬盘      致钛 TiPlus5000 500G      327              Mac副硬盘      日立 1T      ??              Win硬盘      致钛 TiPlus5000 1T      420              OpenKylin硬盘      三星 860evo 256GB      ??              声卡      螃蟹 ALC892 Codec      无              无线模块      Intel AX200      70              网卡      螃蟹 8111H      无              机箱      小喆C2P白色      80              电源      TT SFX钢影450W      300              屏幕      熊猫 2k 75Hz      500              -      -      2857        主板、CPU、显卡这些虽然已经有点过时，但是应付日常使用没有问题，买的时候看看E类PCIE口是否支持NGFF，两千五百块钱（只有一块硬盘）的机子，普通人应该不会有那么多硬盘，2TB的致态需要854元（2024.3.15），内存其实骇客神条就行，所以不会超过三千块钱。不玩游戏的可以试试。引导  Opencore 0.9.3  如果你只有一个Mac系统，可以禁用以下三项：系统  Snonma 14.4  Windows 11  UOS 22 (家庭版)正常的功能  CPU  显卡  声卡  USB  有线网卡  变频  睡眠  Wifi  蓝牙（无法隔空投送等操作）  博通的网卡被炒的太高了，后面又换了AX200模块，使用的PCI-E短口。  自己自行注入三码，三码重复会封你的Apple号，怎么注入Google搜一下就有。文件    下载链接：EFI      如果下载链接有问题，请联系我mail@rainsin.cn，务必注明来意。  效果"
  },
  
  {
    "title": "我的OwO表情包Data-API",
    "url": "/posts/owo/",
    "categories": "API",
    "tags": "API",
    "date": "2024-02-28 16:32:10 +0800",
    





    
    "snippet": "如果你的网站使用了OwO.js，就可以使用这个API。表情包都来自于这个仓库，我只取了其中的一部分，并将它们转换为了webp格式，加载会快一点。使用  国内使用： https://rainsin-1305486451.file.myqcloud.com/rainsin-blog/emo/emoticon.json   全球使用： https://blog.rainsin.cn/emotico...",
    "content": "如果你的网站使用了OwO.js，就可以使用这个API。表情包都来自于这个仓库，我只取了其中的一部分，并将它们转换为了webp格式，加载会快一点。使用  国内使用： https://rainsin-1305486451.file.myqcloud.com/rainsin-blog/emo/emoticon.json   全球使用： https://blog.rainsin.cn/emoticon/emoticon.json我使用的表情包列表你可以下载一些喜欢的表情包，自己做一个API。搜索引擎社区文化 40 张拒绝伸手党。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/搜索引擎.zip机场社区文化 48 张上车吗，不限速。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/机场.zip猫狗整合宠物 107 张还没分好类，之后会分开的。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/猫狗整合.zip白白在吃啥原创人物 58 张作者未知，可爱可爱可爱。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/白白在吃啥.zip贴吧大表情社区文化 93 张贴吧大表情，由 pandecheng - 酷安 提供并进行无损放大处理。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/贴吧大表情.zip酷安小表情社区文化 363 张酷安 小表情。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/酷安小表情.zip猥琐萌原创人物 158 张来源于 pandecheng - 酷安 收集，在各个社交平台都很火，我也蛮喜欢这个。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/猥琐萌.zip呆萌小人原创人物 58 张呆萌小人表情包，来源未知。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/呆萌小人.zip商业头盔原创人物 144 张网络流传，来源未知。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/商业头盔.zip突然 XX原创人物 60 张作者未知。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/突然%20XX.zip七濑胡桃汉化原创人物 121 张七濑胡桃的汉化版本，汉化作者为绯色天空，原作者为 joynet 所属的画师 ぽむ - Pixiv，原版贴图来源于 LINE。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/七濑胡桃汉化.zip小坏坏原创人物 58 张由  pandecheng - 酷安 收集。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/小坏坏.zip披被子的滑稽原创人物 58 张作者 pandecheng - 酷安。            001      002      003      004      005                                                表情包下载https://emoticon.kallydev.com/packages/披被子的滑稽.zip"
  },
  
  {
    "title": "奥山和纱 写真集 Clear",
    "url": "/posts/ao-shan/",
    "categories": "写真",
    "tags": "写真, 奥山和纱",
    "date": "2024-02-26 16:32:10 +0800",
    





    
    "snippet": "    奥山和纱（奥山かずさ、おくやま かずさ），1994年3月10日出生于日本青森县，日本女演员、模特，隶属于OSCAR PROMOTION      壁纸文件： 奥山和纱 写真集 Clear 【蓝奏云】，解压码：奥山。 奥山和纱 写真集 Clear 【OneDrive】。  ",
    "content": "    奥山和纱（奥山かずさ、おくやま かずさ），1994年3月10日出生于日本青森县，日本女演员、模特，隶属于OSCAR PROMOTION      壁纸文件： 奥山和纱 写真集 Clear 【蓝奏云】，解压码：奥山。 奥山和纱 写真集 Clear 【OneDrive】。  "
  },
  
  {
    "title": "使用certbot和Let’s Encrypt为本地服务器部署ssl",
    "url": "/posts/ssl-certbot/",
    "categories": "解决问题",
    "tags": "解决问题",
    "date": "2024-02-02 16:32:10 +0800",
    





    
    "snippet": "以前我的树莓派的SSL一直需要我在51SSL上手动申请，然后下载证书到服务器，比较麻烦。最近借着过年部署了一下certbot来完成申请证书的操作，记录一下过程。1. 安装 Certbotsudo apt-get install certbot2. 申请通配符证书sudo certbot -d domain.com -d \"*.domain.com\" --manual --preferred-...",
    "content": "以前我的树莓派的SSL一直需要我在51SSL上手动申请，然后下载证书到服务器，比较麻烦。最近借着过年部署了一下certbot来完成申请证书的操作，记录一下过程。1. 安装 Certbotsudo apt-get install certbot2. 申请通配符证书sudo certbot -d domain.com -d \"*.domain.com\" --manual --preferred-challenges dns certonly --server https://acme-v02.api.letsencrypt.org/directory会得到以下输出：Saving debug log to /var/log/letsencrypt/letsencrypt.logPlugins selected: Authenticator manual, Installer NonePerforming the following challenges:dns-01 challenge for domain.com- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -NOTE: The IP of this machine will be publicly logged as having requested thiscertificate. If you're running certbot in manual mode on a machine that is notyour server, please ensure you're okay with that.Are you OK with your IP being logged?- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(Y)es/(N)o: 输入Yes同意将本机对的IP地址记录下来，接着系统显示下面的信息- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Please deploy a DNS TXT record under the name_acme-challenge.domain.com with the following value:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXBefore continuing, verify the record is deployed.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Press Enter to Continue在你的域名的DNS中加入一条TXT记录，记录名 _acme-challenge 值为上面的XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX, 然后按回车验证你的DNS记录成功后，将为你颁发证书，证书会生成到/etc/letsencrypt/live/domain.com/ 目录下。 domain.com 是你申请的域名。Waiting for verification...Cleaning up challengesIMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at:   /etc/letsencrypt/live/domain.com/fullchain.pem   Your key file has been saved at:   /etc/letsencrypt/live/domain.com/privkey.pem   Your cert will expire on 2020-06-14. To obtain a new or tweaked   version of this certificate in the future, simply run certbot   again. To non-interactively renew *all* of your certificates, run   \"certbot renew\" - If you like Certbot, please consider supporting our work by:   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate   Donating to EFF:                    https://eff.org/donate-le3. 更新apache2证书为每个主机加上：&lt;VirtualHost *:2000&gt;    ServerName  xxx.domain.com    ServerAlias xxx    SSLEngine on    SSLProxyEngine On    SSLProxyCheckPeerCN Off    SSLProxyVerify none    + SSLCertificateFile /etc/letsencrypt/live/domain.com/cert.pem    + SSLCertificateKeyFile /etc/letsencrypt/live/domain.com/privkey.pem    + SSLCertificateChainFile /etc/letsencrypt/live/domain.com/chain.pem    &lt;Proxy *&gt;            Order deny,allow            Allow from all    &lt;/Proxy&gt;    ProxyPreserveHost On    ProxyRequests On    ProxyPass / http://localhost:xxxx/    ProxyPassReverse / http://localhost:xxxx/&lt;/VirtualHost&gt;service apache2 force-reloadservice apache2 restart4. 自动续期编辑计划任务crontab -e输入下面的表达式（每天 00:00:00），让他每天都尝试一次关闭 Nginx-&gt;更新-&gt;启动 Apache2，到了最后 30 天的时候就会成功。0 0 * * * \"service nginx stop ; /bin/certbot renew --renew-by-default; service nginx start\"crontab的使用实例实例1：每1分钟执行一次myCommand* * * * * myCommand实例2：每小时的第3和第15分钟执行3,15 * * * * myCommand实例3：在上午8点到11点的第3和第15分钟执行3,15 8-11 * * * myCommand实例4：每隔两天的上午8点到11点的第3和第15分钟执行3,15 8-11 */2  *  * myCommand实例5：每周一上午8点到11点的第3和第15分钟执行3,15 8-11 * * 1 myCommand实例6：每晚的21:30重启smb30 21 * * * /etc/init.d/smb restart实例7：每月1、10、22日的4 : 45重启smb45 4 1,10,22 * * /etc/init.d/smb restart实例8：每周六、周日的1 : 10重启smb10 1 * * 6,0 /etc/init.d/smb restartFAQ证书重置请求超过次数，一般 3 次，子域名除外。就会出现如下错误，5 天以后才可以再次重置。An unexpected error occurred: There were too many requests of a given type :: Error creating new order :: too many certificates already issu for exact set of domains: blog.frankfeekr.cn: see https://letsencrypt.org/docs/rate-limits/"
  },
  
  {
    "title": "使用 CloudFlare 导致网站「重定向的次数过多」解决方案",
    "url": "/posts/cloudflare/",
    "categories": "解决问题",
    "tags": "解决问题",
    "date": "2024-02-01 12:22:10 +0800",
    





    
    "snippet": "一句话解决在 CloudFlare 的 SSL/TLS 菜单里将「SSL/TLS 加密模式」设置为完全（Strict）即可。",
    "content": "一句话解决在 CloudFlare 的 SSL/TLS 菜单里将「SSL/TLS 加密模式」设置为完全（Strict）即可。"
  },
  
  {
    "title": "使用Latex写论文、讲义",
    "url": "/posts/latex/",
    "categories": "Latex, 论文",
    "tags": "latex",
    "date": "2023-12-27 11:33:00 +0800",
    





    
    "snippet": "  LaTeX（/ˈlɑːtɛx/，常被读作/ˈlɑːtɛk/或/ˈleɪtɛk/），是一种基于TEX的排版系统，由美国计算机科学家莱斯利·兰伯特在20世纪80年代初期开发，利用这种格式系统的处理，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能，不必一一亲自去设计或校对，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突...",
    "content": "  LaTeX（/ˈlɑːtɛx/，常被读作/ˈlɑːtɛk/或/ˈleɪtɛk/），是一种基于TEX的排版系统，由美国计算机科学家莱斯利·兰伯特在20世纪80年代初期开发，利用这种格式系统的处理，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能，不必一一亲自去设计或校对，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学、物理文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。—-来自维基百科优势：  支持跨平台使用  天然支持数学符号和表格  使用模版可以解决格式问题，让你可以专注于内容的创作而非格式排版上  社区活跃，有问题可以快速解决  更改方便，所见即所得环境安装：安装最简单了，下载对应安装包安装即可：Mac：MacTex、MikTexWindows: MikTexLinux: MikTex使用：我使用VS code进行编辑，VS code安装包，下载安装就好。你也可以使用线上的OverLeaf进行编辑，你不用安装任何东西，即开即用，而且模版非常丰富。首先，安装好VS code，之后安装两个插件：选择你要使用的模版仓库，复制仓库地址（例：长安大学硕士论文模版）：克隆仓库：输入地址，选择存储路径即可。克隆完成后用vscode打开文件夹，就可以看到如下图所示的按钮：打开之后就是编译，预览等选项，之后就可以愉快的使用Latex了，Latex的学习应该在写文章的过程中去边查边写，好好利用搜索引擎，这样可以更快掌握。"
  },
  
  {
    "title": "基础排序算法之基数排序",
    "url": "/posts/radix-sort/",
    "categories": "考研, 数据结构",
    "tags": "排序, 基数排序",
    "date": "2023-07-20 12:32:10 +0800",
    





    
    "snippet": "排序算法之基数排序前期准备我们提前定义一下基础操作：template &lt;class E&gt;class Sort{protected:    // 得到最大值索引    static int v_max_index(vector&lt;E&gt; &amp;a)    {        int biggest = (int)*max_element(begin(a), end(a))...",
    "content": "排序算法之基数排序前期准备我们提前定义一下基础操作：template &lt;class E&gt;class Sort{protected:    // 得到最大值索引    static int v_max_index(vector&lt;E&gt; &amp;a)    {        int biggest = (int)*max_element(begin(a), end(a));        return biggest;    }    // 得到最小值索引    static int v_min_index(vector&lt;E&gt; &amp;a)    {        int biggest = (int)*min_element(begin(a), end(a));        return biggest;    }}具体过程假定我们有一个待排数组a[]={213,119,32,10,1,21}。我们新建两个辅助数组count[]和tmp[]，count[]记录当前位的元素个数，每位的数值是[0...9]这个范围，所以count[]的长度为10，tmp[]辅助存储a[]的元素，长度和a[]的相等，基数排序不是一个原地排序。int l = a.size();vector&lt;E&gt; temp(l);vector&lt;E&gt; count(10, 0);int k = 0;//提取当前的位数的值int digit = 1;如下图：首先，我们要定义一个方法max_digit()获取a[]的最大值的位数d，比如上面的最大值为213，所以d = 3。这个d控制最外层的循环，以便依次对个位、十位、百位∙∙∙∙∙∙进行处理，基数排序先对最低有效位进行排序。// 得到最大位数static int max_digit(vector&lt;E&gt; &amp;a){     int max = v_max_index(a);     int d = 1;     while (max &gt;= 10)     {         max = max / 10;         d++;     }     return d;}然后我们进行类似计数排序的过程，1. 创建count[]数组第一步是先将count[]所有元素重置为0，现在是刚开始的阶段，我们初始化位置控制变量p = 1 ，即从个位开始，我们先对个位的数值进行统计，初始化一个遍历指针i = 0，取出a[0] = 213，得到该元素的个位k = (a[0] / digit ) % 10 = (213 / 1) % 10 = 3，将count[k]加一，即个位为3的元素多了一个，之后i++进行下一轮循环，直到遍历完所有元素，如下图：i=0，先取出a[0]进行处理：i=1,取出a[1]：如此重复上述过程直到到达最后一个元素：部分代码如下：for (int j = 0; j &lt; l; j++){    k = (a[j] / digit) % 10;    count[k]++;}最后我们得到了一个个位的计数数组count[]={1,2,1,1,0,0,0,0,0,1}，下一步是将这个数组进行一个处理，使得其可以表征一些位置信息，比如个位为1的元素位置在个位为0的元素后面在个位为2的元素前面，怎么实现这个处理，其实很简单，只需当前位的个数加上减一位的个数：count[i] = count[i] + count[i - 1]，得到处理过的count[]，过程如下：代码如下：for (int j = 1; j &lt; 10; j++)    count[j] = count[j] + count[j - 1];2.使用上述生成的count[]进行排序这个过程比较简单，就是倒过来遍历a[]，经过式$(1)$的变化得到经过个位排序的tmp[]，然后把tmp[]复制到a[]。\\[a\\left[ j\\right]  \\xrightarrow[]{k\\  =\\  \\left( a\\left[ j\\right]  \\  /\\  digit\\right)  \\  /\\  10} tmp\\left[ count\\left[ k\\right]  -1\\right]  \\  =\\  a\\left[ j\\right]  \\rightarrow count\\left[ k\\right]  \\  =\\  count\\left[ k\\right]  \\  -\\  1\\tag{1}\\]过程如下：然后将count[1]的值减一，之后j = 4 :然后将count[1]的值减一，之后j = 3 :然后将count[0]的值减一，之后j = 2 :然后将count[2]的值减一，上图的count[0]应为0，不想改图了，之后j = 1 :然后将count[9]的值减一，之后j = 0 :这样我们就排好了个位的顺序，然后我们将tmp[]的内容复制给a[]，将digit = digit * 10= 1 * 10 = 10来提取十位的数值，进行下一轮的循环，重复1和2的过程，直到最外层循环超过了最大值位数d为止，后面的具体过程就不具体讲了，可以自己动手模拟模拟。这样我们可以写出代码了：\t// 基数排序    static void Radix(vector&lt;E&gt; &amp;a)    {        int l = a.size();        vector&lt;E&gt; temp(l);        vector&lt;E&gt; count(10, 0);        int k = 0;        int digit = 1;        int d = max_digit(a);        for (int i = 1; i &lt;= d; i++)        {            for (int j = 0; j &lt; 10; j++)                count[j] = 0;            for (int j = 0; j &lt; l; j++)            {                k = (a[j] / digit) % 10;                count[k]++;            }            for (int j = 1; j &lt; 10; j++)                count[j] = count[j] + count[j - 1];            for (int j = l - 1; j &gt;= 0; j--)            {                k = (a[j] / digit) % 10;                temp[count[k] - 1] = a[j];                --count[k];            }            for (int j = 0; j &lt; l; j++)                a[j] = temp[j];            digit = digit * 10;        }    }测试首先需要一个生成测试用例的函数：// 测试用例生成// n为生成的数量，RangeL和RangeR表示生成的数在这两个之间static vector&lt;E&gt; generateRandomA(int n, int RangeL, int RangeR){    vector&lt;E&gt; a;    if (RangeL &gt; RangeR)    {        int temp = RangeL;        RangeL = RangeR;        RangeR = temp;    }    srand((unsigned)time(NULL));    for (int i = 0; i &lt; n; i++)    {        a.push_back((E)(rand() % (RangeR - RangeL + 1) + RangeL));    }    return a;}还需要一个时间测试函数，时间精确到纳秒(ns)：static long long getCurrentTimeNano(){    return std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch()).count();}将升序的数组反向排序：// 将降序排列static void re_vet(vector&lt;E&gt; &amp;a){    std::sort(a.rbegin(), a.rend());}随后进行测试：int main(){    int max = 20000;    int min = 0;    int num = 30000;    vector&lt;int&gt; a = Sort&lt;int&gt;::generateRandomA(num, min, max);        startTime = (double) Sort&lt;int&gt;::getCurrentTimeNano();    Sort&lt;int&gt;::Radix(a5);    endTime = (double) Sort&lt;int&gt;::getCurrentTimeNano();    elapsedNanoseconds = (endTime - startTime)/1000000.0;    printf(\"基数排序平均情况所需时间: %f ms\\n\", elapsedNanoseconds);    startTime = (double) Sort&lt;int&gt;::getCurrentTimeNano();    Sort&lt;int&gt;::Radix(a5);    endTime = (double) Sort&lt;int&gt;::getCurrentTimeNano();    elapsedNanoseconds = (endTime - startTime)/1000000.0;    printf(\"基数排序有序情况所需时间: %f ms\\n\", elapsedNanoseconds);    //反向排序    Sort&lt;int&gt;::re_vet(a5);    startTime = (double) Sort&lt;int&gt;::getCurrentTimeNano();    Sort&lt;int&gt;::Radix(a5);    endTime = (double) Sort&lt;int&gt;::getCurrentTimeNano();    elapsedNanoseconds = (endTime - startTime)/1000000.0;    printf(\"基数排序逆序情况所需时间: %f ms\\n\", elapsedNanoseconds);    cout &lt;&lt; endl;}结果：待排数组有30000个元素。基数排序平均情况所需时间: 4.363448 ms基数排序有序情况所需时间: 4.207993 ms基数排序逆序情况所需时间: 5.190794 ms分析空间复杂度：我们用到了和输入数组等大小的辅助数组和一个固定大小的辅助数组，故空间复杂度为$O(n+1) = O(n)$。时间复杂度：其时间复杂度为$O (nlog(r)m)$，其中$r$为所采取的基数，而$m$为堆数。基数排序是一个稳定的算法。可视化过程：输入：768个元素，范围在[0, 256]。"
  },
  
  {
    "title": "使用Opencore引导多个系统",
    "url": "/posts/more-system-opencore/",
    "categories": "黑苹果, EFI",
    "tags": "黑苹果, EFI, Openkylin, Deepin, Ubuntu, Debian, Windows10, Windows11, MacOS, Linux",
    "date": "2023-07-02 12:23:00 +0800",
    





    
    "snippet": "前提Mac可以正常引导，其他系统都已经安装好了（本文使用UEFI+GPT引导，传统的方式需要自己查找资料）。步骤      在OpenCore中安装OpenShell.efi工具。    下载OpenShell.efi在/EFI/OC/tool路径下，一般OC自带这个文件不用单独下。    在OC中进行如下设置:  重启。        如果你的OC隐藏了辅助条目，则在开机引导界面看不到UE...",
    "content": "前提Mac可以正常引导，其他系统都已经安装好了（本文使用UEFI+GPT引导，传统的方式需要自己查找资料）。步骤      在OpenCore中安装OpenShell.efi工具。    下载OpenShell.efi在/EFI/OC/tool路径下，一般OC自带这个文件不用单独下。    在OC中进行如下设置:  重启。        如果你的OC隐藏了辅助条目，则在开机引导界面看不到UEFI Shell项，按空格键就会显示出来，之后选择UEFI Shell项回车进入。            找到所有的要引导的系统的EFI文件分区    FS1:,FS2:,…FS12：是连接到系统的所有硬盘设备的分区，你必须确定哪个是Windows分区，哪个是Mac分区，哪个是Linux分区：    ls或dir命令查看文件目录，cd /路径进入文件目录。熟悉Linux的这些命令都很熟悉，用这些命令找根目录长下面这样的FS：        键入cd EFI，看文件目录，如果有Microsoft文件夹就是windows的EFI分区，如果有Deepin文件夹就是Linux/deepin的EFI分区，记住这些分区对应的FS{n}。    进入你知道的那个EFI分区，比如FS2是windows的EFI分区对应的文件系统，你就可以进入这个分区FS2:，输入map &gt; fast.txt，这个分区根目录就会保存一个fast.txt的文本文件，里面保存着路径信息，当然你也可以选择其它你知道的分区。    我以我的为例： 经过上述步骤我知道我的FS0是OC的分区，FS2是Windows的分区，FS4是Deepin的分区，FS6是OpenKylin的分区，我的分区信息文件保存在windows的EFI分区下，通过OCC工具挂载EFI分区，找到这个文件，记住相应的路径：            在OC中设置    在Misc-&gt;Boot-&gt;Entries中添加条目，Path项就是我们上面得到的那些设备路径再加上具体的EFI文件路径，比如下面这个是我们找到的Windows的设备路径：     PciRoot(0x0)/Pci(0x17,0x0)/Sata(0x1,0xFFFF,0x0)/HD(1,GPT,1EFB24B9-9F07-4C77-8B75-B7D467010F2C,0x800,0x96000)         则Path为     PciRoot(0x0)/Pci(0x1B,0x0)/Pci(0x0,0x0)/NVMe(0x1,EA-AE-B4-91-56-38-25-00)/HD(1,GPT,A64D3A6A-2333-4107-AAA2-6EFD5A06180E,0x800,0x96000) /\\EFI\\Microsoft\\Boot\\bootmgfw.efi        前面的设备路径和后面的文件路径中间有一个空格，如果是Linux，后面的文件路径是     /\\EFI\\{Linux发行版名称}\\grubx64.efi         比如我用的是Deepin则文件路径为 /\\EFI\\deepin\\grubx64.efi。    我的设置：            一些小设置                  如果你想自定义你的引导项标题比如下面这样：                可以到对应的EFI目录下更改.contentDetails文件                    如果开机蓝屏，可能你的路径不对，或者在OC中打开下面的项目，我也忘了是具体哪一个生效的，都试试吧        Kernel中的设置：                Booter中的设置：                    "
  },
  
  {
    "title": "黑苹果Venture 13.4 Intel无线网卡(AX200,AX201,AX210,AX203)蓝牙问题排查",
    "url": "/posts/ax200-bluetooth/",
    "categories": "黑苹果, 解决问题",
    "tags": "黑苹果, 解决问题",
    "date": "2023-07-02 12:23:00 +0800",
    





    
    "snippet": "信息      系统：Venture 13.4.1 (22F82)    网卡：AX200  情况使用 IntelBluetoothFirmware和BlueToolFix之后wifi可以正常使用，蓝牙无法使用，12版本应该没有这个问题。前提USB已经定制好了，给蓝牙预留一个USB端口排查      把Lilu，BlueToolFix更新到最新。        使用这个构建的IntelBlu...",
    "content": "信息      系统：Venture 13.4.1 (22F82)    网卡：AX200  情况使用 IntelBluetoothFirmware和BlueToolFix之后wifi可以正常使用，蓝牙无法使用，12版本应该没有这个问题。前提USB已经定制好了，给蓝牙预留一个USB端口排查      把Lilu，BlueToolFix更新到最新。        使用这个构建的IntelBluetoothFirmware驱动，如果这个不行就使用最新。        在NVRAM-&gt;add中的7C436110-AB2A-4BBB-A880-FE41995C9F82中添加两项，如下表                            键          值          数据类型                                      bluetoothInternalControllerInfo          00000000 00000000 00000000 0000          Data                          bluetoothExternalDongleFailed          00          Data                      如果你在文本编辑器里编辑，则填入     &lt;key&gt;bluetoothInternalControllerInfo&lt;/key&gt; &lt;data&gt;AAAAAAAAAAAAAAAAAAA=&lt;/data&gt; &lt;key&gt;bluetoothExternalDongleFailed&lt;/key&gt; &lt;data&gt;AA==&lt;/data&gt;        值并不一样，因为编码不一样。        关闭kernel中的XhciPortLimit项        运行下面的命令     sudo rm -rf /Library/Preferences/com.apple. bluetooth.plist            重置NVRAM，一次不行就两次    随航，隔空投送都没法驱动"
  },
  
  {
    "title": "单链表的C++实现",
    "url": "/posts/list-cpp/",
    "categories": "考研, 数据结构",
    "tags": "单链表",
    "date": "2023-06-12 16:32:10 +0800",
    





    
    "snippet": "单链表的C++实现自己独立实现一遍，记忆深刻。实现#pragma once#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;template &lt;class T&gt;class Node{public:    const T _data;    Node&lt;T&gt; *_next; // 下一个...",
    "content": "单链表的C++实现自己独立实现一遍，记忆深刻。实现#pragma once#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;template &lt;class T&gt;class Node{public:    const T _data;    Node&lt;T&gt; *_next; // 下一个结点    Node() : _data(0)    {        _next = nullptr;    };    Node(const T &amp;v) : _data(v)    {        _next = nullptr;    };};template &lt;class T&gt;class LinkList{private:    Node&lt;T&gt; *_head;  // 头结点    Node&lt;T&gt; *_stern; // 尾结点    Node&lt;T&gt; *_temp;  // 操作实现的中间使用变量    mutable size_t _size;public:    LinkList();                                   // 构建一个单链表;    LinkList(const T &amp;v);                         // 头结点设置为特殊值（如果有需要）    ~LinkList();                                  // 销毁一个单链表;    void CreateLinkList(vector&lt;T&gt; &amp;n);            // 使用一个向量创建一个单链表    void CreateLinkList(T n[], size_t len);       // 使用一个数组创建一个单链表    void CreateLinkList(size_t len);              // cin输入创建一个单链表    size_t GetSize();                             // 获取线性表长度    bool IsEmpty();                               // 判断单链表是否为空    vector&lt;int&gt; Find(const T &amp;data);              // 查找节点    vector&lt;int&gt; ForDeleteFind(const T &amp;data);     // 查找结点，返回该值的索引递减数组，该序列只能用于删除操作    Node&lt;T&gt; *FindIndex(int index);                // 查找索引节点    void InsertElemAtEnd(const T &amp;data);          // 在尾部插入指定的元素    void InsertElemAtIndex(const T &amp;data, int n); // 在指定位置插入指定元素    void InsertElemAtHead(const T &amp;data);         // 在头部插入指定元素    void DeleteElemAtEnd();                       // 在尾部删除元素    void DeleteElemAtIndex(int n);                // 删除索引元素    void DeleteAll();                             // 删除所有数据    void DeleteElemAtPoint(const T &amp;data);        // 删除指定的数据    void DeleteElemAtHead();                      // 在头部删除节点    void Show();                                  // 展示链表};// 创建一个空链表template &lt;class T&gt;LinkList&lt;T&gt;::LinkList() : _size(0){    this-&gt;_head = this-&gt;_stern = this-&gt;_temp = new Node&lt;T&gt;();};// 创建一个头结点是特殊值的空链表template &lt;class T&gt;LinkList&lt;T&gt;::LinkList(const T &amp;v) : _size(0){    this-&gt;_head = this-&gt;_stern = new Node&lt;T&gt;(v);    this-&gt;_temp = nullptr;};// 销毁一个单链表;template &lt;class T&gt;LinkList&lt;T&gt;::~LinkList(){    delete _head;};// 使用vector创建一个单链表template &lt;class T&gt;void LinkList&lt;T&gt;::CreateLinkList(vector&lt;T&gt; &amp;n){    size_t size = n.size();    for (size_t i = 0; i &lt; size; i++)        this-&gt;InsertElemAtEnd(n[i]);};// 使用一个数组创建单链表template &lt;class T&gt;void LinkList&lt;T&gt;::CreateLinkList(T n[], size_t len){    this-&gt;_temp = this-&gt;_head;    for (size_t i = 0; i &lt; len; i++)        this-&gt;InsertElemAtEnd(n[i]);}// cin创建链表template &lt;class T&gt;void LinkList&lt;T&gt;::CreateLinkList(size_t len){    T value;    for (size_t i = 0; i &lt; len; i++)    {        cout &lt;&lt; \"输入第\" &lt;&lt; i + 1 &lt;&lt; \"元素:\";        cin &gt;&gt; value;        InsertElemAtEnd(value);    }}// 尾部插入template &lt;class T&gt;void LinkList&lt;T&gt;::InsertElemAtEnd(const T &amp;data){    Node&lt;T&gt; *newnd = new Node&lt;T&gt;(data);    this-&gt;_stern-&gt;_next = newnd;    this-&gt;_stern = newnd;    this-&gt;_size++;};// 头插template &lt;class T&gt;void LinkList&lt;T&gt;::InsertElemAtHead(const T &amp;data){    Node&lt;T&gt; *newnd = new Node&lt;T&gt;(data);    this-&gt;_temp = this-&gt;_head-&gt;_next;    this-&gt;_head-&gt;_next = newnd;    newnd-&gt;_next = this-&gt;_temp;    this-&gt;_size++;}// 查找结点，返回该值的索引数组template &lt;class T&gt;vector&lt;int&gt; LinkList&lt;T&gt;::Find(const T &amp;data){    vector&lt;int&gt; value = vector&lt;int&gt;();    this-&gt;_temp = this-&gt;_head;    int j = 0;    while (this-&gt;_temp != nullptr)    {        if (data == this-&gt;_temp-&gt;_data)        {            value.push_back(j);        }        j++;        this-&gt;_temp = this-&gt;_temp-&gt;_next;    }    return value;}// 查找结点，返回该值的索引递减数组，该序列只能用于删除操作template &lt;class T&gt;vector&lt;int&gt; LinkList&lt;T&gt;::ForDeleteFind(const T &amp;data){    vector&lt;int&gt; value = vector&lt;int&gt;();    this-&gt;_temp = this-&gt;_head;    int i = 0, j = 0;    while (this-&gt;_temp != nullptr)    {        if (data == this-&gt;_temp-&gt;_data)        {            value.push_back(j - i);            i++;        }        j++;        this-&gt;_temp = this-&gt;_temp-&gt;_next;    }    return value;}// 使用索引查找结点template &lt;class T&gt;Node&lt;T&gt; *LinkList&lt;T&gt;::FindIndex(int index){    this-&gt;_temp = this-&gt;_head;    if (index &gt; this-&gt;_size || index &lt; 0)        return nullptr;    if (index == 0)        return this-&gt;_head;    for (int l = index; l &gt; 0; l--)        this-&gt;_temp = this-&gt;_temp-&gt;_next;    return this-&gt;_temp;}// 在索引位置插入元素template &lt;class T&gt;void LinkList&lt;T&gt;::InsertElemAtIndex(const T &amp;data, int n){    if (n &gt; this-&gt;_size + 1 || n &lt;= 0)        return;    if (n == this-&gt;_size + 1)        this-&gt;InsertElemAtEnd(data);    this-&gt;_temp = FindIndex(n - 1);    Node&lt;T&gt; *newnd = new Node&lt;T&gt;(data);    Node&lt;T&gt; *tnd = this-&gt;_temp-&gt;_next;    this-&gt;_temp-&gt;_next = newnd;    newnd-&gt;_next = tnd;    this-&gt;_size++;}// 删除该索引位置元素template &lt;class T&gt;void LinkList&lt;T&gt;::DeleteElemAtIndex(int n){    if (n &gt; this-&gt;_size || n &lt;= 0)        return;    this-&gt;_temp = FindIndex(n - 1);    Node&lt;T&gt; *tnd = this-&gt;_temp-&gt;_next;    this-&gt;_temp-&gt;_next = this-&gt;_temp-&gt;_next-&gt;_next;    if (n == this-&gt;_size)        this-&gt;_stern = this-&gt;_temp;    delete tnd;    tnd = nullptr;    this-&gt;_temp = nullptr;    this-&gt;_size--;}// 在尾部删除元素template &lt;class T&gt;void LinkList&lt;T&gt;::DeleteElemAtEnd(){    if (this-&gt;_size == 0)        return;    Node&lt;T&gt; *tnd = this-&gt;FindIndex(this-&gt;_size - 1);    tnd-&gt;_next = nullptr;    this-&gt;_stern = tnd;    this-&gt;_size--;}// 删除所有元素template &lt;class T&gt;void LinkList&lt;T&gt;::DeleteAll(){    this-&gt;_temp = this-&gt;_head-&gt;_next;    this-&gt;_head-&gt;_next = nullptr;    delete this-&gt;_temp;    this-&gt;_temp = nullptr;    this-&gt;_stern = this-&gt;_head;    this-&gt;_size = 0;}//删除所有的值等于的结点template &lt;class T&gt;void LinkList&lt;T&gt;::DeleteElemAtPoint(const T &amp;data){    vector&lt;int&gt; indexs = this-&gt;ForDeleteFind(data);    for (auto i : indexs)        this-&gt;DeleteElemAtIndex(i);}//删除头结点template &lt;class T&gt;void LinkList&lt;T&gt;::DeleteElemAtHead(){    if (this-&gt;_head-&gt;_next == nullptr)        return;    this-&gt;_temp = this-&gt;_head-&gt;_next;    this-&gt;_head-&gt;_next = this-&gt;_head-&gt;_next-&gt;_next;    delete this-&gt;_temp;    this-&gt;_temp = nullptr;    this-&gt;_size--;}// 表是否为空template &lt;class T&gt;bool LinkList&lt;T&gt;::IsEmpty(){    return this-&gt;_size == 0;}// 表长template &lt;class T&gt;size_t LinkList&lt;T&gt;::GetSize(){    return this-&gt;_size;}template &lt;class T&gt;void LinkList&lt;T&gt;::Show(){    this-&gt;_temp = this-&gt;_head-&gt;_next;    while (this-&gt;_temp != nullptr)    {        if (this-&gt;_temp-&gt;_next == nullptr)            cout &lt;&lt; this-&gt;_temp-&gt;_data;        else            cout &lt;&lt; this-&gt;_temp-&gt;_data &lt;&lt; \"-&gt;\";        this-&gt;_temp = this-&gt;_temp-&gt;_next;    }    cout &lt;&lt; endl;    this-&gt;_temp = this-&gt;_head;};测试#include &lt;iostream&gt;#include \"head/List.h\"#include &lt;vector&gt;using namespace std;template&lt;typename T&gt;void log(T &amp;a){    cout &lt;&lt; a &lt;&lt; endl;}int main(){    vector&lt;int&gt; s = vector&lt;int&gt;();    for (size_t i = 0; i &lt; 5; i++)    {        s.push_back(i * i);    }    for(int a=0;a&lt;10;a++){        if(a % 2 == 0)            s.push_back(25);        else            s.push_back(12);    }    LinkList&lt;int&gt; lists = LinkList&lt;int&gt;();    lists.CreateLinkList(s);    lists.Show();    log(\"删除25:\");    lists.DeleteElemAtPoint(25);    lists.Show();    log(\"删除尾:\");    lists.DeleteElemAtEnd();    lists.Show();    log(\"删除头:\");    lists.DeleteElemAtHead();    lists.Show();    log(\"删除第四个:\");    lists.DeleteElemAtIndex(4);    lists.Show();    log(\"尾部插入:\");    lists.InsertElemAtEnd(114);    lists.Show();    log(\"头部插入:\");    lists.InsertElemAtHead(154);    lists.Show();    log(\"第一个位置插入:\");    lists.InsertElemAtIndex(366,1);    lists.Show();    cout &lt;&lt; \"长度为：\" &lt;&lt;  lists.GetSize() &lt;&lt; endl;    cout &lt;&lt; \"是否为空：\" &lt;&lt; lists.IsEmpty() &lt;&lt; endl;    lists.DeleteAll();    cout &lt;&lt; \"长度为：\" &lt;&lt;  lists.GetSize() &lt;&lt; endl;    cout &lt;&lt; \"是否为空：\" &lt;&lt; lists.IsEmpty() &lt;&lt; endl;    return 0;}输出：0-&gt;1-&gt;4-&gt;9-&gt;16-&gt;25-&gt;12-&gt;25-&gt;12-&gt;25-&gt;12-&gt;25-&gt;12-&gt;25-&gt;12删除25:0-&gt;1-&gt;4-&gt;9-&gt;16-&gt;12-&gt;12-&gt;12-&gt;12-&gt;12删除尾:0-&gt;1-&gt;4-&gt;9-&gt;16-&gt;12-&gt;12-&gt;12-&gt;12删除头:1-&gt;4-&gt;9-&gt;16-&gt;12-&gt;12-&gt;12-&gt;12删除第四个:1-&gt;4-&gt;9-&gt;12-&gt;12-&gt;12-&gt;12尾部插入:1-&gt;4-&gt;9-&gt;12-&gt;12-&gt;12-&gt;12-&gt;114头部插入:154-&gt;1-&gt;4-&gt;9-&gt;12-&gt;12-&gt;12-&gt;12-&gt;114第一个位置插入:366-&gt;154-&gt;1-&gt;4-&gt;9-&gt;12-&gt;12-&gt;12-&gt;12-&gt;114长度为：10是否为空：0长度为：0是否为空：1"
  },
  
  {
    "title": "红黑树",
    "url": "/posts/red-black-tree/",
    "categories": "考研, 数据结构",
    "tags": "数据结构, 二叉查找树, 2-3查找树, 红黑树",
    "date": "2023-06-12 12:23:00 +0800",
    





    
    "snippet": "一、前言在普通平衡二叉树中我们知道平衡条件苛刻，平衡条件很容易被打破，因此需要频繁的调整全树的结构，代价太大了，应用并不广。下面介绍一种平衡条件放宽的数据结构，它的所有操作都在对数时间内完成。二、2-3查找树2.1 定义  一颗2-3查找树或为一颗空树，或由下列结点组成：      2-结点：只有一个键，两条链接的结点，如图1-1。    3-结点：有两个键，三条链接的结点，如图1-2。  ...",
    "content": "一、前言在普通平衡二叉树中我们知道平衡条件苛刻，平衡条件很容易被打破，因此需要频繁的调整全树的结构，代价太大了，应用并不广。下面介绍一种平衡条件放宽的数据结构，它的所有操作都在对数时间内完成。二、2-3查找树2.1 定义  一颗2-3查找树或为一颗空树，或由下列结点组成：      2-结点：只有一个键，两条链接的结点，如图1-1。    3-结点：有两个键，三条链接的结点，如图1-2。  图1-1图1-2如图1-3是一颗标准的2-3查找树：图1-32.2 查找假设我们可以很好的操作上面定义的结构，那么我们怎样查找一个元素？树上的结点划分了不同的区间，树越深区间划分的越细，我们查找的是某个以被查找的元素作为端点的区间，如果找到则查找成功，如果永远的落入到一个区间中（非端点），这个区间没有被继续分割（遇到空结点），则查找失败。例如，我们在图1-3中的树上查找C和M：查找C元素（成功）：查找M元素（失败）：2.3 插入2.3.1 在一个2-结点上插入就像在上面查找M元素过程中，最后停到了K结点，K结点是一个2-结点，即未命中查找结束在一个2-结点上，这种情况如何处理？很简单，直接将这个2-结点变为3-结点，插入要插入的键。如图2-1:2.3.2 只有一个3-结点的树中插入插入H：这里的4-结点是非常重要的中间结点，后续的操作都离不开它。2.3.3 向父结点为2-结点的3-结点中插入插入Z：2.3.4 向父结点为3-结点的3-结点中插入插入N：2.3.5 分解根结点如果2.3.4步骤中向上分解到根结点都没有遇到2-结点怎么办？其实很简单，前面的分解都是2.3.4的步骤，到达根结点后执行2.3.2的步骤就行了。2.4 分析上述定义的2-3树操作很直白，容易理解，但是实现起来很复杂，我们需要维护两种结点，实现它们之间的转换，情况还非常多，这不是一件容易的事，代码量会很多。而下面的红黑树是2-3查找树的一种表达，实现起来并不难。三、红黑树3.1 定义王道的定义：一棵红黑树是满足如下红黑性质的二叉排序树：  每个结点或是红色，或是黑色的。  根结点是黑色的。  叶结点（虚构的外部结点、NULL结点）都是黑色的。  不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色的）。  对每个结点，从该结点到任一叶结点的简单路径上，所含黑结点的数量相同。另一种定义是我们将讨论的颜色对象换为链接而非结点（颜色的变量在结点中，但是我们使用的时候是这样使用的node.left.color，就好像是链接颜色一样）：  红链接均为左链接  没有结点同时和两条红链接相连  完美黑色平衡2-3查找树定义红黑树：  红链接将两个2-结点连接起来构成3-结点，都是左斜的  黑链接是2-3树中的普通链接如果我们将一棵红黑树的红链接画平，那么所有空链接到根链接的距离都是相同的。我们将图1-3中的2-3树转换为红黑树：如上图将红链接画平后树是完美平衡的。3.2 实现3.2.1 结点定义及颜色表示//定义颜色#define RED true;#define BLACK false;using Color = bool;template &lt;class Key, class Value&gt; class RBNode{private:    Key key;    Value value;    RBNode&lt;Key,Value&gt; left;    RBNode&lt;Key,Value&gt; right;    int N;    Color color;public:    RBNode(Key &amp;ikey, Value &amp;ivalue, int inum, Color &amp;c){        Key = ikey;        Value = ivalue;        N = inum;        color = c;        left = right = nullptr;    }};上述结点定义还是挺直观的。除此之外还需要一个测试结点与父结点之间链接颜色的函数isRed()和得到以该结点为根的子树的子结点数目size()，实现如下。bool isRed(RBNode&lt;Key,Value&gt; &amp;h){    if(h == nullptr) return false;    return h.color == RED;}int size(RBNode&lt;Key,Value&gt; &amp;h){    if(h == nullptr) {        return 0;    }else{        return h.N;    }; }3.2.2 旋转  左旋转//左转RBNode&lt;Key,Value&gt; rotateLeft(RBNode&lt;Key,Value&gt; &amp;h){    RBNode&lt;Key,Value&gt; x = h.right;    h.right = x.left;    x.left = h;    x.color = h.color;    h.color = RED;    x.N = h.N;    h.N = 1 + size(h.left) + size(h.right);    return x;}  右旋转右旋转是将上面左旋实现进行镜像，left改为right，right改为left。//右转RBNode&lt;Key,Value&gt; rotateRight(RBNode&lt;Key,Value&gt; &amp;h){    RBNode&lt;Key,Value&gt; = h.left;    h.left = x.right;    x.right = h;    x.color = h.color;    h.color = RED;    x.N = h.N;    h.N = 1 + size(h.left) + size(h.right);    return x;}  颜色变化//改变颜色void flipColor(RBNode&lt;Key,Value&gt; &amp;h){    h.color = RED;    h.left.color = BLACK;    h.right.color = BLACK;}  插入的总体实现//...public:    //...    void put(Key &amp;key,Value &amp;value){        root = put(root, key, value);        root.color = BLACK;    }    //...private:    //...    //插入    RBNode&lt;Key,Value&gt; put(RBNode&lt;Key,Value&gt; &amp;h, Key &amp;key, Value &amp;value){        if(h == nullptr){            temp = new RBNode&lt;Key, Value&gt;(Key, Value, 1, RED);            return temp;        }        if(key &gt; h.key){            h.right = put(h.right, key, value);        }else if(key &lt; h.key){            h.left = put(h.left, key, value);        }else{            h.value = value;        }        if(isRed(h.right) &amp;&amp; !isRed(h.left))            h = rotateLeft(h);        if(isRed(h.left) &amp;&amp; isRed(h.left.left))            h = rotateRight(h);        if(isRed(h.left) &amp;&amp; isRed(h.right))            flipColor(h);        h.N = 1 + size(h.left) + size(h.right);        return h;    }    //...//..."
  },
  
  {
    "title": "创建自己的影视库和各种服务",
    "url": "/posts/server-config/",
    "categories": "Server, 音视频",
    "tags": "树莓派, 流程, ubuntu, Emby, Gitea, Apache, Docker, Bt, Bot",
    "date": "2023-06-10 11:33:00 +0800",
    





    
    "snippet": "服务器相关配置万一服务器有问题，按这个步骤来。带星号* 是舍弃的项目。设置su密码：sudo passwd0 终端设置与美化0.1 命令行使用代理安装：sudo apt install proxychains4打开配置文件sudo nano /etc/proxychains4.conf在尾部添加代理服务器协议 + ip + port# socks4 127.0.0.1 9050 # 把原来的...",
    "content": "服务器相关配置万一服务器有问题，按这个步骤来。带星号* 是舍弃的项目。设置su密码：sudo passwd0 终端设置与美化0.1 命令行使用代理安装：sudo apt install proxychains4打开配置文件sudo nano /etc/proxychains4.conf在尾部添加代理服务器协议 + ip + port# socks4 127.0.0.1 9050 # 把原来的注释掉socks5 127.0.0.1 1080使用：proxychains4 &lt;命令&gt;0.2 安装nushell和配置Oh-my-posh0.2.1 安装 Rustsudo apt install gcc #rust必需要的curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh0.2.2 安装依赖sudo apt install pkg-config libssl-devsudo apt install libxcb-composite0-dev libx11-dev0.2.3 使用 crates.io 进行构建cargo install nu安装完毕后，我们可以使用 nu 命令运行 Nu。0.2.4 nu安装扩展将扩展的仓库clone 下来，然后构建执行文件。git clone &lt;repositories.git&gt;cd &lt;repositories&gt;cargo build --releaseregister ./target/release/&lt;repositories&gt;0.2.5 Oh-my-posh参考 官方文档 ，很详尽。效果：1 fstab文件的配置1.1 查看磁盘空间sudo fdisk -l1.2 查看磁盘信息blkid1.3 找到fstab文件cd /etc1.4 打开fstab，我习惯用nanosudo nano fstab1.5 编辑在尾部加入以下LABEL=writable  /       ext4    discard,errors=remount-ro       0 1UUID=\"3C2831055A5270C3\" /mdata ntfs defaults 0 1UUID=\"5CB7E03A333A1F21\" /movie ntfs defaults 0 1UUID=\"26BADED554B2A139\" /rdata ntfs defaults 0 1UUID=\"30B8B9F6B8B9BB24\" /avdata ntfs defaults 0 1UUID=\"451F30BC5E8250E3\" /home/ubuntu/pdata ntfs defaults 0 1ctrl + x保存，重启生效。2 samba配置2.1 安装samba要安装 Samba，我们运行：sudo apt updatesudo apt install samba2.2 设置Samba现在安装了 Samba，我们需要创建一个目录供其共享：mkdir &lt;pathname&gt;上面的命令创建一个新文件夹 sambashare在我们稍后将共享的主目录中，我直接分享 ~ 目录。Samba 的配置文件位于 /etc/samba/smb.conf. 要将新目录添加为共享，我们通过运行以下命令来编辑文件：sudo nano /etc/samba/smb.conf在文件底部，添加以下行：[sambashare] \t\tcomment = &lt;title&gt;    path = &lt;pathname&gt;    read only = no    browsable = yes然后按 Ctrl-O保存和 Ctrl-X退出文本编辑器。现在我们已经配置了新共享，保存它并重新启动 Samba 使其生效：sudo service smbd restart更新防火墙规则以允许 Samba 流量：sudo ufw allow samba由于 Samba 不使用系统帐户密码，因此我们需要为我们的用户帐户设置一个 Samba 密码：sudo smbpasswd -a username //username为用户名windows用IPv6访问：\\\\240e-335-2805-2be0-dea6-32ff-fefe-1496.ipv6-literal.net: 用 - 分隔。3 安装Emby3.1 下载Emby链接：Arm64架构，X64架构3.2 安装dpkg -i emby-server-deb_4.7.11.0_arm64.deb //arm64架构dpkg -i emby-server-deb_4.7.11.0_amd64.deb //X64架构。4 安装Docker安装docker的命令很简单sudo apt updatesudo apt install -y docker.io安装的时间可能有一点长，请耐心等待。。。 安装完成后可能需要启动下。。systemctl start docker设置开机就启动dockersystemctl enable docker查看docker是否安装成功docker version注意这里只显示了Client的信息，下面有一个报错: persission denied…，这个是因为我们安装的时候是用的sudo安装，在这里是没有权限连接docker的服务端，解决办法是把当前用户加入到docker组里面去。首先新建一个docker组sudo groupadd docker但是很可能已经有了docker组了，已有的话就不用管了，继续下一步然后把当前用户加入docker组sudo gpasswd -a ${USER} docker重启dockersudo service docker restart最后一步肥肠重要。。切换当前会话到新 groupnewgrp - docker最后测试下效果docker versionClient: Version:           20.10.12 API version:       1.41 Go version:        go1.17.3 Git commit:        20.10.12-0ubuntu4 Built:             Mon Mar  7 17:11:41 2022 OS/Arch:           linux/arm64 Context:           default Experimental:      trueServer: Engine:  Version:          20.10.12  API version:      1.41 (minimum version 1.12)  Go version:       go1.17.3  Git commit:       20.10.12-0ubuntu4  Built:            Mon Mar  7 15:57:50 2022  OS/Arch:          linux/arm64  Experimental:     false containerd:  Version:          1.5.9-0ubuntu3.1  GitCommit: runc:  Version:          1.1.0-0ubuntu1.1  GitCommit: docker-init:  Version:          0.19.0  GitCommit:最后的最后，因为国内网速问题，下载镜像比较慢所以可以使用国内大厂提供的加速器，我这里使用的是阿里云提供的加速器，使用镜像加速必须得改一下docker的配置文件 /etc/docker/daemon.jsonsudo nano /etc/docker/daemon.json在里面加入镜像加速器地址。。{  \t\t\"registry-mirrors\": [\"https://registry.docker-cn.com\"]}完成。5 安装Bitwarden一款密码管理器开启HTTPS：docker run -d --name bitwarden \\\t-e ROCKET_TLS='{certs=\"/ssl/certs.pem\",key=\"/ssl/key.key\"}' \\  -v /home/ubuntu/Nginx/:/ssl/ \\  -v /Bitwarden/:/data/ \\  -p 443:80 \\  vaultwarden/server:latest6 安装Alist*一款小云盘docker pull xhofe/alist:latestdocker run -d --restart=always -v /home/ubuntu:/opt/alist/data -p 5244:5244 -e UMASK=022 --name=\"alist\" xhofe/alist:latest查看管理员信息：docker exec -it alist ./alist admin可以使用另外一个项目：sudo docker run -d \\    --name=zfile \\    --restart=always \\    -p 3555:8080 \\    -v /root/zfile/conf:/root/.zfile-v4 \\    -v /home/ubuntu/pdata/zfile/file:/root/zfile/data \\\t\tstilleshan/zfile7 安装DDNSdocker run -d --name ddns-go --restart=always --net=host -v /opt/ddns-go:/root jeessy/ddns-go8 安装Excalidraw一款画板工具docker run --rm -dit --name excalidraw -p 5000:80 jauderho/excalidraw9 Apache配置9.1 安装Apachesudo apt-get  install  -y apache29.2 开启Apache中对Webdav协议的支持9.2.1 开启Apache中对Webdav协议的支持 (记住最好在用户目录下执行否则报错)cd ~sudo a2enmod davsudo a2enmod dav_fs9.2.2 创建共享目录并修改权限sudo mkdir -p /var/www/webdavsudo chown -R www-data:www-data  /var/www/webdav9.2.3 创建Webdav的访问用户数据库，顺便创建用户pi和guestsudo htpasswd -c /etc/apache2/webdav.password pi#sudo htpasswd /etc/apache2/webdav.password guest9.2.4 修改用户数据库访问权限sudo chown root:www-data /etc/apache2/webdav.passwordsudo chmod 640 /etc/apache2/webdav.password9.2.5 打开默认配置文件sudo nano /etc/apache2/sites-available/000-default.conf全部替换为以下内容（记得先备份）：Alias /webdav  /var/www/webdav&lt;Location /webdav&gt; Options Indexes DAV On AuthType Basic AuthName \"webdav\" AuthUserFile /etc/apache2/webdav.password Require valid-user&lt;/Location&gt;原文件：&lt;VirtualHost *:80&gt;        # The ServerName directive sets the request scheme, hostname and port that        # the server uses to identify itself. This is used when creating        # redirection URLs. In the context of virtual hosts, the ServerName        # specifies what hostname must appear in the request's Host: header to        # match this virtual host. For the default virtual host (this file) this        # value is not decisive as it is used as a last resort host regardless.        # However, you must set it for any further virtual host explicitly.        #ServerName www.example.com        ServerAdmin webmaster@localhost        DocumentRoot /var/www/html        # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,        # error, crit, alert, emerg.        # It is also possible to configure the loglevel for particular        # modules, e.g.        #LogLevel info ssl:warn        ErrorLog ${APACHE_LOG_DIR}/error.log        CustomLog ${APACHE_LOG_DIR}/access.log combined        # For most configuration files from conf-available/, which are        # enabled or disabled at a global level, it is possible to        # include a line for only one particular virtual host. For example the        # following line enables the CGI configuration for this host only        # after it has been globally disabled with \"a2disconf\".        #Include conf-available/serve-cgi-bin.conf&lt;/VirtualHost&gt;sudo /etc/init.d/apache2 force-reloadsudo /etc/init.d/apache2 restart9.3 设置https前提条件  已下载Apache服务器证书。  已安装Open SSL。环境准备  操作系统：Ubuntu  Web服务器：Apache 21 执行以下命令，在apache2目录下创建ssl目录。mkdir /etc/apache2/cert2 执行以下命令，将下载的阿里云证书文件复制到ssl目录中。cp -r YourDomainName_public.pem /etc/apache2/certcp -r YourDomainName_chain.pem /etc/apache2/certcp -r YourDomainName.key /etc/apache2/cert3 执行以下命令，启用SSL模块sudo a2enmod ssl4 执行以下命令，修改SSL配置文件default-ssl.confnano /etc/apache2/sites-available/default-ssl.conf在default-ssl.conf文件中找到以下参数，修改后保存并退出。&lt;IfModules mod_ssl.c&gt;&lt;VirtualHost *:443&gt;  ...ServerName   #修改为证书绑定的域名。SSLEngine onSSLCertificateFile /home/ubuntu/.ssl/apache2/rainsin.cn_cert.pemSSLCertificateKeyFile /home/ubuntu/.ssl/apache2/rainsin.cn_key.keySSLCertificateChainFile /home/ubuntu/.ssl/apache2/rainsin.cn_chain.pem...&lt;/VirtualHost&gt;&lt;/IfModules5 执行以下命令，把default-ssl.conf映射至/etc/apache2/sites-enabled文件夹中建立软链接，实现两者之间的自动关联。sudo ln -s /etc/apache2/sites-available/default-ssl.conf /etc/apache2/sites-enabled/001-ssl.conf6 执行以下命令，重新加载Apache 2配置文件。sudo /etc/init.d/apache2 force-reloadsudo /etc/init.d/apache2 restart完成。9.4 设置反向代理sudo a2enmod rewrite　　　　//启用.htaccess规则，打开重写sudo a2enmod proxysudo a2enmod proxy_http　　//启用反向代理安装好后，Apache2 HTTP 服务器关于站点的配置文件位于 /etc/apache2/sites-enabled/ 中，我们使用熟悉的编辑器（比如 nano 或者 vim）编辑默认生成的文件：sudo nano /etc/apache2/sites-enabled/000-default.conf在该配置文件的最底部，添加如下配置：&lt;VirtualHost *:2000&gt;  ServerName &lt;二级域名&gt;.rainsin.cn  ServerAlias &lt;二级域名&gt;.rainsin.cn  SSLProxyEngine on  SSLEngine on  SSLCertificateFile /etc/apache2/cert/rainsin.cn/cert.pem  SSLCertificateKeyFile /etc/apache2/cert/rainsin.cn/key.key  SSLCertificateChainFile /etc/apache2/cert/rainsin.cn/chain.pem    ProxyPass / http://localhost:&lt;port&gt;  ProxyPassReverse / http://localhost:&lt;port&gt;&lt;/VirtualHost&gt;我统一将所有的内部端口映射在2000端口上，用二级域名区分应用，在这之前需要将2000端口加入到ports.conf中，不然无法访问。Listen 2000 //你在apache中用的的端口都要在这里配置服务器相关配置。10 安装rss服务器docker run -d \\  --name=freshrss \\  -e PUID=1000 \\  -e PGID=1000 \\  -e TZ=Asia/Shanghai \\  -p 3444:80 \\  -v /home/ubuntu/rss:/config \\  --restart unless-stopped \\  lscr.io/linuxserver/freshrss:latest11 安装komga一款漫画管理阅读软件docker run -d \\  --name=komga \\  --user 1000:1000 \\  -p 2666:8080 \\  -v /home/ubuntu/komga/config:/config \\  -v /home/ubuntu/pdata/komga:/data \\  --restart unless-stopped \\  gotson/komga12 安装webdav主要用来zotero的备份docker run --name webdav \\  --restart=unless-stopped \\  -p 3478:80 \\  -v &lt;webdav-path&gt;:/data \\  -e USERNAME=&lt;webdav&gt; \\  -e PASSWORD=&lt;webdav&gt; \\  -e UDI=1000 \\  -e GID=1000 \\  -d  derkades/webdav13 图床安装13.1 蓝空图床：docker network create lsky-pro-netdocker run -d -p 3306:3306 --name mysql8.0.29 --network lsky-pro-net --network-alias mysql --restart=always -e MYSQL_ROOT_PASSWORD=123456 mysql:8.0.29docker run -d --name=lsky-pro --restart=always --network lsky-pro-net -v /home/ubuntu/pdata/lsky-pro-data:/var/www/html -p 7791:80 dko0/lsky-pro:2.0.4docker exec -it mysql8.0.29 bashmysql -uroot -p123456create user 'lskypro'@'%' identified by '123456';grant all privileges on *.* to 'lskypro'@'%' with grant option;flush privileges;create database lskypro;13.2 Chevereto-free安装：docker run -d   --name=chevereto   -e PUID=1000   -e PGID=1000   -e TZ=Asia/Shanghai   -p 5080:80   -p 9999:443   -v /chevereto/config:/config   -v /mdata:/data   --restart unless-stopped   linuxserver/chevereto:latest13.3 LightPicture的安装：这个没有docker镜像，安装可能比较麻烦，过程中可能会有问题。先决条件：大环境：  apache2  php (7.2~7.4)  MySQL(≥5.5)PHP环境：  PDO扩展  GD库  fileinfo扩展  curl扩展  ZipArchive 支持Apache环境：  rewrite模块  SSL模块13.3.1 安装php（7.4版本）1. 使用apt-fast 提升下载速度的软件，安装软件时，通过增加线程使下载软件速度加快。sudo add-apt-repository ppa:apt-fast/stablesudo apt-get install apt-fast2. 卸载系统中已有的php版本和扩展，如果以前安装过比7.4更高或比7.2更低的版本则需要运行。sudo apt-get autoremove php*3. 添加php7.4的源sudo add-apt-repository ppa:ondrej/php &amp;&amp; sudo apt-get update4. 使用apt-fast 安装php7.4sudo apt-fast -y install php7.45. 可能需要安装的扩展sudo apt-fast install php7.4-fpm php7.4-mysql php7.4-curl php7.4-json php7.4-mbstring php7.4-xml php7.4-intl php7.4-gd php7.4-bcmath php7.4-zip*13.3.2 MySQL的配置MySQL的安装在第17节。需要执行的sql文件在public/install路径下的lp.sql文件。首先，需要创建database，可以使用MySQL管理软件创建也可以命令行进入MySQL创建，然后执行在public/install路径下的lp.sql文件。我使用的是Navicat for windows，mac端好像也有，mac端也可以用Sequel Ace、MySQL Workbench、TablePlus等等。也可以使用命令行：sudo mysql -u root -p输入密码，进入mysql：CREATE DATABASE &lt;name&gt;;use &lt;name&gt;;source /path/to/lp.sql;systemctl restart php-fpm.service13.3.3 Apache2配置将以下配置添加进apache的任意可生效的conf文件中：&lt;VirtualHost *:2000&gt;\t\t\t\t#你的域名，端口2000可以改        ServerName  &lt;url-name&gt;        ServerAlias &lt;title&gt;\t\t\t\t#HTTPS配置        SSLEngine on        SSLCertificateFile /home/ubuntu/.ssl/apache2/rainsin.cn_cert.pem        SSLCertificateKeyFile /home/ubuntu/.ssl/apache2/rainsin.cn_key.key        SSLCertificateChainFile /home/ubuntu/.ssl/apache2/rainsin.cn_chain.pem\t\t\t\t\t\t\t\t#设置为public的绝对路径        DocumentRoot /path/to/public\t\t\t\t#首页文件        DirectoryIndex index.html index.php\t\t\t\t#public文件的权限必须为可读可写，运行 chmod 755 /项目根目录/public        &lt;Directory \"/LightPicture/public\"&gt;                Options FollowSymLinks ExecCGI                AllowOverride All                Order allow,deny                Allow from all                Require all granted        &lt;/Directory&gt;        ErrorLog ${APACHE_LOG_DIR}/error.log        CustomLog ${APACHE_LOG_DIR}/access.log combined&lt;/VirtualHost&gt;将以下文字添加进 public/.htaccess 中：&lt;IfModule mod_rewrite.c&gt;  Options +FollowSymlinks -Multiviews  RewriteEngine On  RewriteCond %{REQUEST_FILENAME} !-d  RewriteCond %{REQUEST_FILENAME} !-f  RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/IfModule&gt;开启rewrite模块：sudo **a2enmod rewrite**重启apache2：sudo /etc/init.d/apache2 force-reloadsudo /etc/init.d/apache2 restart13.3.4 安装完成设置config/database.php 文件：&lt;?phpreturn [    // 默认使用的数据库连接配置    'default'         =&gt; env('database.driver', 'mysql'),    // 自定义时间查询规则    'time_query_rule' =&gt; [],    // 自动写入时间戳字段    // true为自动识别类型 false关闭    // 字符串则明确指定时间字段类型 支持 int timestamp datetime date    'auto_timestamp'  =&gt; true,    // 时间字段取出后的默认时间格式    'datetime_format' =&gt; 'Y-m-d H:i:s',    // 时间字段配置 配置格式：create_time,update_time    'datetime_field'  =&gt; '',    // 数据库连接配置信息    'connections'     =&gt; [        'mysql' =&gt; [            // 数据库类型            'type'            =&gt; env('database.type', 'mysql'),            // 服务器地址            'hostname'        =&gt; env('database.hostname', '127.0.0.1'),            // 数据库名            'database'        =&gt; env('database.database', 'name'),            // 用户名            'username'        =&gt; env('database.username', 'root'),            // 密码            'password'        =&gt; env('database.password', 'password'),            // 端口            'hostport'        =&gt; env('database.hostport', '3306'),            // 数据库连接参数            'params'          =&gt; [],            // 数据库编码默认采用utf8            'charset'         =&gt; env('database.charset', 'utf8'),            // 数据库表前缀            'prefix'          =&gt; env('database.prefix', 'osuu_'),            // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器)            'deploy'          =&gt; 0,            // 数据库读写是否分离 主从式有效            'rw_separate'     =&gt; false,            // 读写分离后 主服务器数量            'master_num'      =&gt; 1,            // 指定从服务器序号            'slave_no'        =&gt; '',            // 是否严格检查字段是否存在            'fields_strict'   =&gt; true,            // 是否需要断线重连            'break_reconnect' =&gt; false,            // 监听SQL            'trigger_sql'     =&gt; env('app_debug', true),            // 开启字段缓存            'fields_cache'    =&gt; false,        ],        // 更多的数据库配置信息    ],];在浏览器中输入http(s)://ip+port/install 进行安装，第一步会检查环境是否配置完成，会显示未配置好的部分，根据它的提示配置好后第二步就填写MySQL的信息，最后完成。。14 博客安装*docker run \\  -it -d \\  --name halo \\  -p 8090:8090 \\  -v &lt;path&gt;:/root/.halo2 \\  halohub/halo:2.2.0 \\  --halo.external-url=http://localhost:8090/ \\  --halo.security.initializer.superadminuser=admin \\  --halo.security.initializer.superadminpassword=P@88w0rd备份数据（重要）cp -r &lt;path&gt; &lt;备份path&gt;15 minio安装*这是一个对象存储服务。首先将域名的证书文件复制到&lt;config-path&gt;/certs下，&lt;config-path&gt;这是自定义的一个路径，将在后面映射在docker容器中，证书命名为private.key和public.crt，注意pem可以直接重命名为crt。然后运行： docker run --network=host \\    -p 9000:9000 -p 9001:9001 --name minio \\    -d --restart=always \\    -e \"MINIO_ACCESS_KEY=&lt;username&gt;\" \\    -e \"MINIO_SECRET_KEY=&lt;password&gt;\" \\    -e \"MINIO_SERVER_URL=https://minio.rainsin.cn:9000\" \\    -v &lt;data-path&gt;:/data \\    -v &lt;config-path&gt;:/root/.minio \\    minio/minio server /data --console-address \"minio.rainsin.cn:9001\" --address \"minio.rainsin.cn:9000\"不加network=host（访问宿主机网络），可能minio.rainsin.cn这个域名无法使用。MINIO_SERVER_URL为分享链接域名。以下弃用：nohup sudo MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=ABC871220 minio server /home/ubuntu/pdata/minio/data --console-address \":9001\" &amp;16 ddns域名列表ddns.rainsin.cnhm.rainsin.cnemby.rainsin.cnrss.rainsin.cnmima.rainsin.cnpan.rainsin.cnphoto.rainsin.cndraw.rainsin.cnwebdav.rainsin.cnbook.rainsin.cnbt.rainsin.cnsys.rainsin.cn17 MySQL安装sudo apt-get install mysql-server设置root账户配置为使用密码进行身份验证，并且设置密码：ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'mypassword';FLUSH PRIVILEGES;'localhost' 可以改为'%' ，mypassword 是你的密码。然后输入：sudo mysql_secure_installation输入上面设置的密码，之后全部n。设置外网访问：mysql -u root -pmysql&gt;use mysql;mysql&gt;update user set host = '%' where user =’root’;mysql&gt;flush privileges;mysql&gt;select host,user from user where user='root';使用sql文件初始化数据库:mysql -u root -p dbname&lt;filename.sql  注意：dbname是自定义的数据库名，且必须先创建好。18 图书管理系统*docker run -d --restart=always --name calibresrv_web -p 8083:8083 -v /mdata/book/config:/config -v /mdata/book/Library:/books -v /mdata/book/Books_Calibre:/Books_Calibre -v /mdata/book/Books_Calibre_Backup:/Books_Calibre_Backup \\-v /mdata/book/Backup_Library:/Backup_Library  -e NOTIFICATIONS=enabled -e TOKEN=\"xxxxxxxxxxxxxxxxxxxxxxxxx\" -e CHATID=\"xxxxxxxxx\"  -d mephistoxol/calibresrv_webdocker run -d --name=calibre --security-opt seccomp=unconfined `#optional` -e PUID=1000 -e PGID=1000 -e TZ=Asia/Shanghai -e PASSWORD= `#optional` -e CLI_ARGS= `#optional` -p 8082:8080 -p 8081:8081 -v /path/to/data:/config --restart unless-stopped linuxserver/calibre:latest19 Bt下载管理器*19.1 transmission和qBittorrent的安装及配置下载种子和做种工具。qBittorrent的默认用户名/密码：admin/adminadmin 。舍弃：docker create --name=qbittorrent  -e WEBUIPORT=8080 -e PUID=1026 -e PGID=100 -e TZ=Asia/Shanghai -p 6881:6881 -p 6881:6881/udp -p 8087:8080 -v /mdata/bt/config:/config  -v /mdata/bt/download:/downloads --restart unless-stopped superng6/qbittorrent:latestdocker start qbittorrentdocker run -d --name=transmission -e PUID=1000 -e PGID=1000 -e TZ=Asia/Shanghai -e TRANSMISSION_WEB_HOME=/transmission-web-control/src -e USER=&lt;user&gt; -e PASS=&lt;pass&gt; -e WHITELIST=* -e PEERPORT=51413 -e HOST_WHITELIST=* -p 9091:9091 -p 51413:51413 -p 51413:51413/udp -v /mdata/config:/config -v /mdata/bt/downloads:/downloads -v /mdata/bt/watch/folder:/watch -v /home/ubuntu/transmission-web-control:/transmission-web-control --restart unless-stopped linuxserver/transmission:latest19.1.1 下载 transmission-web-controlGitHub地址：https://github.com/ronggang/transmission-web-controlGitee 地址： https://gitee.com/culturist/transmission-web-control国内推荐在 Gitee 下载。解压文件到本地目录。19.1.2 配置邮箱通知      安装bsd-mailx     sudo apt-fast install bsd-mailx                配置s-nail     sudo nano /etc/s-nail.rc        配置邮箱SMTP服务：     set from=\"xxxxxxxx@qq.com\"   #用来发送邮件的邮箱 set smtp=\"smtps://smtp.qq.com:465\" #你所选邮箱的SMTP服务器 set smtp-auth-user=\"xxxxxxxx@qq.com\"  set smtp-auth-password=\"XXXXXXXXXXXX\"  #邮箱授权码 set smtp-auth=login            测试     echo \"小可爱！\" | s-nail -s \"这是个测试邮件！\" xxxxxxxx@qq.com             Tg通知准备    https://t.me/BotFather，打开与它的聊天界面，不论是 Windows mac 还是 Android iOS 的 telegram 客户端。                  创建 bot 以及获取 token        输入 /newbot后回车，它会回复以下内容：                  Alright, a new bot. How are we going to call it? Please choose a name for your bot.                    这个名字是显示名称 （display name）,不是唯一识别码，现在随便设置一下，之后可以通过 /setname修改，比如设置成Zhang san's sweety bot 。              接着会让你设置唯一名称。字符串必须 endsWith bot，比如 abc_bot或 Hellobot都是合法的。如果你设置的名字已经被占用需要重新设置。比如你设置成了 test_bot 。                  Good. Now let’s choose a username for your bot. It must end in bot . Like this, for example: TetrisBot or tetris_bot.                            恭喜！设置成功。会返回给你重要的 API token，务必要保存好它。另外你的 bot 的唯一 url 就已经生成: [https://t.me/test_bot](https://t.me/test_bot) 。                  Done! Congratulations on your new bot. You will find it at  t.me/test_bot. You can now add a description, about section and profile  picture for your bot, see /help for a list of commands. By the way, when  you’ve finished creating your cool bot, ping our Bot Support if you  want a better username for it. Just make sure the bot is fully  operational before you do this.          Use this token to access the HTTP API:12345678:sdfsfadsfasdfasdfasdfgdfhdfghfghKeep your token secure and store it safely, it can be used by anyone to control your bot.          For a description of the Bot API, see this page: https://core.telegram.org/bots/api                红色的字符就是BOT API的TOKEN。            一些其他必要的命令：                  /setdescription 帮助你设置 bot 的描述          /setuserpic 设置 bot 的头像。上传的图片 size 需要大于等于 150x150。而且上传图片需要选择压缩，不能上传文件！                            获取chat_id        使用的url：https://api.telegram.org/bot{token}/getUpdates        使用第4步获得的 token替换上述 url 中的 {token}然后得到新的 url，复制粘贴到浏览器地址栏，回车请求。不出意外你会得到如下 response         {     \"ok\": true,     \"result\": [] }                很好。这时你打开你的 bot，随便和它说一句话，比如给它发一句 “Hello World”，或者将机器人添加进一个自建的群组或者频道，然后重新请求一遍上述的 url（替换过 token 的），不出意外你收到的 response 是这样了         {\"ok\":true,\"result\":[{\"update_id\":248345768, \"my_chat_member\":{\"chat\":{**\"id\":-1001779449685**,\"title\":\"BT\\u72b6\\u6001\\u673a\",\"type\":\"supergroup\"},\"from\":{\"id\":1270423426,\"is_bot\":false,\"first_name\":\"Bill\",\"last_name\":\"Wang\",\"username\":\"Rainsins\"},\"date\":1678610811,\"old_chat_member\":{\"user\":{\"id\":6213936314,\"is_bot\":true,\"first_name\":\"chatGPT\",\"username\":\"rainsinchat_bot\"},\"status\":\"left\"},\"new_chat_member\":{\"user\":{\"id\":6213936314,\"is_bot\":true,\"first_name\":\"chatGPT\",\"username\":\"rainsinchat_bot\"},\"status\":\"member\"}}},{\"update_id\":248345769, \"message\":{\"message_id\":4,\"from\":{\"id\":1270423426,\"is_bot\":false,\"first_name\":\"Bill\",\"last_name\":\"Wang\",\"username\":\"Rainsins\"},\"chat\":{\"id\":-929935885,\"title\":\"BT\\u72b6\\u6001\\u673a\",\"type\":\"group\",\"all_members_are_administrators\":false},\"date\":1678610811,\"migrate_to_chat_id\":-1001779449685}},{\"update_id\":248345770, \"message\":{\"message_id\":1,\"from\":{\"id\":1087968824,\"is_bot\":true,\"first_name\":\"Group\",\"username\":\"GroupAnonymousBot\"},\"sender_chat\":{\"id\":-1001779449685,\"title\":\"BT\\u72b6\\u6001\\u673a\",\"type\":\"supergroup\"},\"chat\":{\"id\":-1001779449685,\"title\":\"BT\\u72b6\\u6001\\u673a\",\"type\":\"supergroup\"},\"date\":1678610811,\"migrate_from_chat_id\":-929935885}},{\"update_id\":248345771, \"message\":{\"message_id\":2,\"from\":{\"id\":1270423426,\"is_bot\":false,\"first_name\":\"Bill\",\"last_name\":\"Wang\",\"username\":\"Rainsins\"},\"chat\":{\"id\":-1001779449685,\"title\":\"BT\\u72b6\\u6001\\u673a\",\"type\":\"supergroup\"},\"date\":1678610813,\"new_chat_participant\":{\"id\":5042722248,\"is_bot\":true,\"first_name\":\"\\u5c0fC-\\u5de5\\u5177\\u4eba\",\"username\":\"CAOYYDS_BOT\"},\"new_chat_member\":{\"id\":5042722248,\"is_bot\":true,\"first_name\":\"\\u5c0fC-\\u5de5\\u5177\\u4eba\",\"username\":\"CAOYYDS_BOT\"},\"new_chat_members\":[{\"id\":5042722248,\"is_bot\":true,\"first_name\":\"\\u5c0fC-\\u5de5\\u5177\\u4eba\",\"username\":\"CAOYYDS_BOT\"}]}},{\"update_id\":248345772, \"message\":{\"message_id\":3,\"from\":{\"id\":1270423426,\"is_bot\":false,\"first_name\":\"Bill\",\"last_name\":\"Wang\",\"username\":\"Rainsins\"},\"chat\":{\"id\":-1001779449685,\"title\":\"BT\\u72b6\\u6001\\u673a\",\"type\":\"supergroup\"},\"date\":1678610831,\"new_chat_participant\":{\"id\":1745206100,\"is_bot\":true,\"first_name\":\"\\u6d88\\u606f\\u4e91\\u2601\\ufe0f\",\"username\":\"MsgWikiBot\"},\"new_chat_member\":{\"id\":1745206100,\"is_bot\":true,\"first_name\":\"\\u6d88\\u606f\\u4e91\\u2601\\ufe0f\",\"username\":\"MsgWikiBot\"},\"new_chat_members\":[{\"id\":1745206100,\"is_bot\":true,\"first_name\":\"\\u6d88\\u606f\\u4e91\\u2601\\ufe0f\",\"username\":\"MsgWikiBot\"}]}},{\"update_id\":248345773, \"message\":{\"message_id\":5,\"from\":{\"id\":1270423426,\"is_bot\":false,\"first_name\":\"Bill\",\"last_name\":\"Wang\",\"username\":\"Rainsins\",\"language_code\":\"zh-hans\"},\"chat\":{\"id\":1270423426,\"first_name\":\"Bill\",\"last_name\":\"Wang\",\"username\":\"Rainsins\",\"type\":\"private\"},\"date\":1678614094,\"text\":\"/start\",\"entities\":[{\"offset\":0,\"length\":6,\"type\":\"bot_command\"}]}}]}                如果有json美化插件，可能会好找一些，如果浏览器没有安装一些 json 美化插件，那么复制它们到任何一个在线 json 解析格式化网站，比如https://www.sojson.com/选择对应的格式化功能格式化文本。         {   \"ok\": true,   \"result\": [     {       \"update_id\": 248345768,       \"my_chat_member\": {         \"chat\": {           **\"id\": -1001779449685,**           \"title\": \"BT状态机\",           \"type\": \"supergroup\"         },         ......       }     },     .....   ] }                知道了 token 和 chatId 就可以使用 bot 了。        curl 测试         curl -s -X POST https://api.telegram.org/bot{token}/sendMessage -d chat_id={chatId} -d text=\"Hello World\"                          配置通知脚本    transmission和qbittorrent的参数不同需要分别配置。可以将它们的脚本分别放在两个文件夹。     cd /var sudo mkdir tm qb cd tm &amp;&amp; sudo touch btmail.sh btadd.sh btseed.sh  cd ../ cd qb &amp;&amp; sudo touch btmail.sh btadd.sh sudo chmod +xr  /var/tm/*.sh /var/qb/*.sh        然后分别编辑，可以自己写一些功能，比如通知tg、通知邮件、磁力管理（需要bash的一些知识）。    btmail.sh 为磁力下载完成时运行，btadd.sh为添加磁力成功后运行，btseed.sh为磁力任务完成后运行。    transmission变量规则：          TR_APP_VERSION - Transmission的版本, e.g. 4.0.0      TR_TIME_LOCALTIME      TR_TORRENT_BYTES_DOWNLOADED - 磁力下载字节数      TR_TORRENT_DIR - 磁力下载位置      TR_TORRENT_HASH - 磁力哈希      TR_TORRENT_ID      TR_TORRENT_LABELS - 磁力标签      TR_TORRENT_NAME - 磁力名字 (不是文件名)      TR_TORRENT_TRACKERS - 磁力trcaker列表        transmission可以添加以下内容，可以自由更改：     #!/bin/sh     NAIL=/usr/bin/s-nail PROXY=/usr/bin/proxychains4 #代理命令，telegram需要。     totalsize=${TR_TORRENT_BYTES_DOWNLOADED}     #格式化容量，将B转换为MB，GB等单位 totalsize=${torrent_size} if [ 1024 -gt $totalsize ];        then size=\"$totalsize\"B elif [ 1048576 -gt $totalsize ];        then        size=`echo  \"scale=3; a = $totalsize / 1024 ; if (length(a)==scale(a)) print 0;print a\"  | bc ` \tsize=\"$size\"KB elif [ 1073741824 -gt $totalsize ];        then        size=`echo  \"scale=3; a = $totalsize / 1048576 ; if (length(a)==scale(a)) print 0;print a\"  | bc ` \tsize=\"$size\"MB elif [ 1073741824 -le $totalsize ];        then        size=`echo  \"scale=3; a = $totalsize / 1073741824 ; if (length(a)==scale(a)) print 0;print a\"  | bc ` \tsize=\"$size\"GB else        size=\"0\"         fi     #telegram通知     TMPFILETG=$(mktemp -t qbittorent.XXXXXXXXXX) #bot的TOKEN，和chat_id，获取方法参见上条。 TOKEN=********:************************** chat_ID=-***************     #信息内容 cat &gt; $TMPFILETG &lt;&lt; EOF *亲，transmission有个磁力🧲下载完成了，赶紧去看看!* --- 客户端：transmission-${TR_APP_VERSION}， 磁力名称：${TR_TORRENT_NAME}， 磁力大小：${size}， 保存地址：${TR_TORRENT_DIR}， 磁力链接：*magnet:?xt=urn:btih:${TR_TORRENT_HASH}*， 添加时间：$(date '+%Y-%m-%d %H:%M:%S')， 发扬互联网精神，抵制迅雷吸血💩。 发扬互联网精神,让每一个种子都生根发芽❀。 EOF     #读取内容 DATA=`cat $TMPFILETG`     MODE='Markdown' URL=\"https://api.telegram.org/bot${TOKEN}/sendMessage\"     #还可以发送视频，图片等，具体可以参考tg bot api官网     $PROXY curl -s -o /dev/null -X POST $URL -d chat_id=${chat_ID} -d parse_mode=${MODE} -d text=\"${DATA}\"     #邮件通知     #要发送的邮件 TO_ADDR1=\"**********@gmail.com\" TO_ADDR2=\"***********@qq.com\" #TO_ADDR2=\"***********@163.com\"     #邮件主题 SUBJECT=\"亲，transmission有个磁力🧲下载完成了，赶紧去看看!\"     #发送邮件 $NAIL -s \"$SUBJECT\" \"$TO_ADDR1\" &lt; \"$TMPFILETG\" $NAIL -s \"$SUBJECT\" \"$TO_ADDR2\" &lt; \"$TMPFILETG\"     #删除临时文件 rm \"$TMPFILETG\"        qbittorrent变量规则：          %N：Torrent 名称      %L：分类      %G：标签（以逗号分隔）      %F：内容路径（与多文件 torrent 的根目录相同）      %R：根目录（第一个 torrent 的子目录路径）      %D：保存路径      %C：文件数      %Z：Torrent 大小（字节）      %T：当前 tracker      %I: 信息哈希值 v1      %J：信息哈希值 v2      %K: Torrent ID        qbittorrent的设置与transmission不一样，transmission直接输入脚本路径就行，qb的不一样         bash /var/qb/btadd.sh \"%N\" \"%F\" \"%R\" \"%D\" \"%C\" \"%Z\" \"%I\" \"%J\"        参数的传入次序很重要，在脚本中我们要用这个次序接收参数：     #!/bin/sh     torrent_name=$1 content_dir=$2 root_dir=$3 save_dir=$4 files_num=$5 torrent_size=$6 file_hash=$7 file_hash2=$8 label=$9 ......        我的qbittorrent脚本：     #!/bin/sh     torrent_name=$1 content_dir=$2 root_dir=$3 save_dir=$4 files_num=$5 torrent_size=$6 file_hash=$7 file_hash2=$8 label=$9     totalsize=${torrent_size}     if [ 1024 -gt $totalsize ];        then size=\"$totalsize\"B elif [ 1048576 -gt $totalsize ];        then        size=`echo  \"scale=3; a = $totalsize / 1024 ; if (length(a)==scale(a)) print 0;print a\"  | bc ` \tsize=\"$size\"KB elif [ 1073741824 -gt $totalsize ];        then        size=`echo  \"scale=3; a = $totalsize / 1048576 ; if (length(a)==scale(a)) print 0;print a\"  | bc ` \tsize=\"$size\"MB elif [ 1073741824 -le $totalsize ];        then        size=`echo  \"scale=3; a = $totalsize / 1073741824 ; if (length(a)==scale(a)) print 0;print a\"  | bc ` \tsize=\"$size\"GB else        size=\"0\"         fi     PROXY=/usr/bin/proxychains4 NAIL=/usr/bin/s-nail     TMPFILETG=$(mktemp -t qbittorent.XXXXXXXXXX) TOKEN=***********:*************************** chat_ID=-*************     cat &gt; $TMPFILETG &lt;&lt; EOF *亲，有个磁力🧲播种完成了，功德加一!* --- 客户端：qBittorent 4.5.2 磁力名称：${torrent_name}， 磁力大小：${size}， 保存地址：${save_dir}， 磁力链接：*magnet:?xt=urn:btih:${file_hash}*， 添加时间：$(date '+%Y-%m-%d %H:%M:%S')， 发扬互联网精神，抵制迅雷吸血💩。 发扬互联网精神,让每一个种子都生根发芽❀。 [动图番号：SSNI-784](https://qcc.woimg.net/images/2020/10/06/ssni-784-1.gif) EOF     DATA=`cat $TMPFILETG`     MODE='Markdown' URL=\"https://api.telegram.org/bot${TOKEN}/sendMessage\"     $PROXY curl -s -o /dev/null -X POST $URL -d chat_id=${chat_ID} -d parse_mode=${MODE} -d text=\"${DATA}\"     #TO_ADDR为你要通知的邮箱 TO_ADDR1=\"********@gmail.com\" TO_ADDR2=\"***********@qq.com\"     SUBJECT=\"亲，有个磁力🧲播种完成了，功德加一!\"     $NAIL -s \"$SUBJECT\" \"$TO_ADDR1\" &lt; \"$TMPFILETG\" $NAIL -s \"$SUBJECT\" \"$TO_ADDR2\" &lt; \"$TMPFILETG\"     rm \"$TMPFILETG\"      19.1.3 安装transmission      安装     sudo add-apt-repository ppa:ubuntuhandbook1/transmission #最新版PPA     sudo apt-fast update     sudo apt-fast install transmission sudo apt-fast install transmission-daemon            修改配置    修改之前停止transmission-daemon服务，不然会回滚：     sudo service transmission-daemon stop         sudo nano /var/lib/transmission-daemon/info/settings.json        修改：     { \t\t...... \t\t\"blocklist-enabled\": true,#黑名单列表     \"blocklist-url\":\"https://cors.isteed.cc/github.com/ttgapers/transmission-blocklist/releases/download/untagged-529f8302ad5115daf99a/blocklist.gz\"     ......     \"rpc-authentication-required\": true     \"rpc-bind-address\": \"0.0.0.0\",      \"rpc-enabled\": true,      \"rpc-password\": \"123456\",      \"rpc-port\": 9091,      \"rpc-url\": \"/transmission/\",      \"rpc-username\": \"transmission\",      \"rpc-whitelist\": \"*\",      \"rpc-whitelist-enabled\": true,      ...... \t\t\"script-torrent-done-enabled\": true,     \"script-torrent-done-filename\": \"/btmail.sh\",#邮件通知脚本     \"script-torrent-added-enabled\":true,     \"script-torrent-added-filename\":\"/btadd.sh\",#添加任务后运行脚本     \"script-torrent-done-seeding-enabled\":true,     \"script-torrent-done-seeding-filename\":\"/btseed.sh\",#任务完成后通知脚本 \t\t...... }            更改WEB-UI    以下方法弃用：     wget https://gitee.com/culturist/transmission-web-control/raw/master/release/install-tr-control-gitee.sh sudo bash install-tr-control-gitee.sh        如果过程中有如下错误：cp: cannot stat '/tmp/tr-web-control/transmission-web-control/src/.': No such file or directory 则需要自行创建文件。    首先将第一步下载的文件解压复制到/tmp/tr-web-control 路径下，然后运行chmod -R 777 /tmp/tr-web-control/transmission-web-control/src/ ，最后再运行上述脚本。    最后，开启服务：     sudo service transmission-daemon start        新方法：     💡 上述脚本对于最新客户端不生效，一直提示连接失败，因为最新的客户端的网页文件夹名字改为了`public_html` 而不是`web` 。         直接下载主题文件：     wget https://proxy.zyun.vip/https://github.com/ronggang/transmission-web-control/archive/refs/tags/v1.6.1-update1.zip unzip transmission-web-control-1.6.1-update1.zip #解压出来，用啥工具都行 cd transmission-web-control-1.6.1-update1 #进入目录     sudo rm /usr/share/transmission/public_html #删除本来的public文件夹 sudo cp -r src /usr/share/transmission/public_html #复制       19.2.4 效果19.2.5 安装qBittorrent      安装add-apt-repository命令(非必需)     sudo apt-get update &amp;&amp; sudo apt-get install software-properties-common -y            添加qbittorrent-nox的PPA软件源     # qBittorrent 稳定版 sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-stable     # qBittorrent 测试版 sudo add-apt-repository ppa:qbittorrent-team/qbittorrent-unstable            安装qbittorrent-nox     sudo apt-get update &amp;&amp; sudo apt-get install qbittorrent-nox -y            设置开机启动     sudo apt-get install vim -y &amp;&amp; vim /etc/systemd/system/qbittorrent-nox.service         [Unit]     Description=qBittorrent-nox     After=network.target     [Service]     User=root     Type=forking     RemainAfterExit=yes     ExecStart=/usr/bin/qbittorrent-nox -d     [Install]     WantedBy=multi-user.target        修改qbittorrent-nox.service文件后重新载入     sudo systemctl daemon-reload        启动和停止     sudo systemctl start qbittorrent-nox sudo systemctl stop qbittorrent-nox        开机自启     sudo systemctl enable qbittorrent-nox            验证     默认账号：admin 密码：adminadmin     默认登陆网址：http://ip:8080            ip国家不显示问题的解决    下载文件：    dbip-country-lite.mmdb    先进入root用户：     su        将文件复制到qbittorrent目录（下面的目标路径是用sudo apt安装qb时所用路径，其他的自行寻找）：     cp 你的dbip-county-lite.mmdb路径 /root/.local/share/qBittorrent/dbip-county-lite.mmdb        重启服务即可。      最后反向代理，完成。19.2.6 效果20 设置clash代理Clash 下载在 Clash release 页面下载相应的版本，对于 Ubuntu 一般使用 clash-linux-amd64-vX.X.X.gz 版本：wget https://github.com/Dreamacro/clash/releases/download/v1.10.0/clash-linux-arm64-v1.10.0.gz  如果直接 wget 速度较慢的话，可以本地下载完成后，使用 SFTP 上传到 Linux 服务器。然后使用 gunzip 命令解压，并重命名为 clash：gunzip clash-linux-amd64-v1.10.0.gzmv clash-linux-amd64-v1.10.0 clash为 clash 添加可执行权限：chmod u+x clashClash 运行时需要 Country.mmdb 文件，当第一次启动 Clash 时（使用 ./clash 命令） 会自动下载（会下载至 /home/XXX/.config/clash 文件夹下）。自动下载可能会因网络原因较慢，可以访问该链接手动下载。  Country.mmdb 文件利用 GeoIP2 服务能识别互联网用户的地点位置，以供规则分流时使用。配置文件一般的网络服务提供了 Clash 订阅链接，可以直接下载链接指向的文件内容，保存到 config.yaml 中。或者使用订阅转换服务（如该链接。也可以自行搭建，可参考该文章），将其它订阅转换为 Clash 订阅。这里推荐使用订阅转换服务，转换后的配置文件已添加更为强大的分流规则。就可以将 Clash 一直保持后台运行，自动分流，且会自动选择最优节点。  Clash 配置文件的完整参数介绍见官方文档。  如果使用订阅转换服务，对于转换后的订阅链接，可以使用以下命令来下载配置文件：curl -o config.yaml 'longURL'对于 suo.yt 短链接，需要重定向，因此使用以下命令来下载配置文件：curl -L -o config.yaml 'shortURL'Clash as a daemon将 Clash 转变为系统服务，从而使得 Clash 实现常驻后台运行、开机自启动等。  普通用户需要 sudo 权限。配置 systemd 服务Linux 系统使用 systemd 作为启动服务器管理机制，首先把 Clash 可执行文件拷贝到 /usr/local/bin 目录，相关配置拷贝到 /etc/clash 目录。sudo mkdir /etc/clashsudo cp clash /usr/local/binsudo cp config.yaml /etc/clash/sudo cp Country.mmdb /etc/clash/创建 systemd 服务配置文件 sudo vim /etc/systemd/system/clash.service：[Unit]Description=Clash daemon, A rule-based proxy in Go.After=network.target[Service]Type=simpleRestart=alwaysExecStart=/usr/local/bin/clash -d /etc/clash[Install]WantedBy=multi-user.target使用 systemctlsudo systemctl daemon-reload使用以下命令，让 Clash 开机自启动：sudo systemctl enable clash然后开启 Clash：sudo systemctl start clash查看 Clash 日志：sudo systemctl status clashsudo journalctl -xe使用代理利用 Export 命令使用代理Clash 运行后，其在后台监听某一端口。Ubuntu 下使用代理，需要 export 命令。根据 config 配置文可以查看到件Clash 代理端口（订阅转换后，端口为7890），设置系统代理命令为：可以将该命令添加到 .bashrc 中，登陆后该用户自动开启代理。取消系统代理：unset  http_proxy  https_proxy  all_proxy  一般下载数据集时，记得取消代理。DashBoard 外部控制外部控制端口为 9090，因此也可以访问该链接，输入 IP 地址（需本机可以访问的 IP）以及端口号 9090，来进入 Clash Dashboard 进行节点的选择。也可以在服务器自行搭建 Clash Dashboard，请参见该项目。不过 Clash Dashboard 用处不大，使用订阅转换后的配置文件包含了自动选择的功能，Clash 会自动选择延迟最低的节点。设置密码export 命令其他用户执行后也可以使用该代理，此时通过可以更换代理端口、添加密码等措施加以限制。修改 /etc/clash/config.yaml 文件部分配置：mixed-port: 12345authentication:  - \"用户名1:密码1\"  - \"用户名2:密码2\"allow-lan: truemode: Rulelog-level: infoexternal-controller: :9090mixed-port: 12345 就是混合代理端口，即使用代理时所指定的端口。然后需要重启 Clash，命令为：sudo systemctl restart clash根据上述配置文件，export 命令变为export https_proxy=http://用户名1:密码1@127.0.0.1:12345 http_proxy=http://用户名1:密码1@127.0.0.1:12345 all_proxy=socks5://用户名1:密码1@127.0.0.1:12345TUN 模式新版的 Clash Premium 内核支持 TUN 模式，且目前已支持 Linux 系统下的 auto-route 和 auto-detect-interface，无需手动设置转发表，可以方便快捷的实现 透明网关（旁路由） 的功能。首先需要下载 Clash Premium 版本，替换上面的 clash 文件。接着需要设置 Linux 系统，开启转发功能。编辑文件 /etc/sysctl.conf，添加以下内容：net.ipv4.ip_forward=1保存退出后，执行以下命令使修改生效：sudo sysctl -p然后接着需要关闭系统的 DNS 服务，使用以下命令：sudo systemctl stop systemd-resolvedsudo systemctl disable systemd-resolved  关于代理环境下 DNS 解析行为的深入探讨，可以参见浅谈在代理环境中的 DNS 解析行为以及我有特别的 DNS 配置和使用技巧。接着需要设置 Clash 的配置文件，添加以下内容：dns:  enable: true  listen: 0.0.0.0:53  enhanced-mode: fake-ip  nameserver:    - 114.114.114.114  fallback:    - 8.8.8.8tun:  enable: true  stack: system # or gvisor  dns-hijack:    - 8.8.8.8:53    - tcp://8.8.8.8:53    - any:53    - tcp://any:53  auto-route: true # auto set global route  auto-detect-interface: true # conflict with interface-nam最后重启 Clash 服务即可，这样流量就会通过 TUN 接口转发，同时利用强大的分流规则，实现按需代理。也可以设置局域网内的网关地址和 DNS 服务器地址，实现透明网关。21 服务器状态监控docker run --restart unless-stopped -it -d --name ward -p 4000:4000 -e WARD_PORT=4000 -e WARD_THEME=dark --privileged antonyleons/ward22 Gitea安装文件：docker-compose.ymlversion: \"3\"networks:  gitea:    external: falseservices:  server:    image: gitea/gitea:1.19.0    container_name: gitea    environment:      - USER_UID=1000      - USER_GID=1000      - GITEA__database__DB_TYPE=mysql      - GITEA__database__HOST=db:3306      - GITEA__database__NAME=gitea      - GITEA__database__USER=gitea      - GITEA__database__PASSWD=gitea    restart: always    networks:      - gitea    volumes:      - /home/ubuntu/pdata/gitea:/data      - /home/ubuntu/pdata/gitea/timezone:/etc/timezone:ro      - /home/ubuntu/pdata/gitea/localtime:/etc/localtime:ro    ports:      - \"3000:3000\"      - \"222:22\"    depends_on:      - db  db:    image: mysql:8    restart: always    environment:      - MYSQL_ROOT_PASSWORD=gitea      - MYSQL_USER=gitea      - MYSQL_PASSWORD=gitea      - MYSQL_DATABASE=gitea    networks:      - gitea    volumes:      - /home/ubuntu/pdata/gitea/mysql:/var/lib/mysql"
  },
  
  {
    "title": "BBtree Search（平衡二叉树）",
    "url": "/posts/b-b-tree/",
    "categories": "考研, 数据结构",
    "tags": "树型查找, 平衡二叉树, 查找",
    "date": "2023-05-22 17:32:10 +0800",
    





    
    "snippet": "1 平衡二叉树为了防止二叉排序树高度的过度增长，我们规定在插入和删除结点时，保证任意结点的左，右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树。定义结点左右，子树的高度差为该结点的平衡因子。如下图：平衡不平衡2 平衡二叉树的插入每当插入一个结点时，检查插入路径上的结点是否因为这次插入操作导致不平衡，如果导致了，则找到插入路径上离插入结点最近的平衡因子大于1的结点，在对该结点进行调整...",
    "content": "1 平衡二叉树为了防止二叉排序树高度的过度增长，我们规定在插入和删除结点时，保证任意结点的左，右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树。定义结点左右，子树的高度差为该结点的平衡因子。如下图：平衡不平衡2 平衡二叉树的插入每当插入一个结点时，检查插入路径上的结点是否因为这次插入操作导致不平衡，如果导致了，则找到插入路径上离插入结点最近的平衡因子大于1的结点，在对该结点进行调整，调整后应该保证二叉排序树的特性，最后二叉树达到平衡。首先约定：每次调整的都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子大于1的结点作为根的子树（下图虚线框中的子树）。⤵️我们将插入结点后形成的最小不平衡子树的根结点记为A，调整不平衡子树有四种情况：      LL平衡旋转    有如下一棵二叉排序树，        在BL上插入了一个结点，使得A的平衡因子变为2:        将这个最小不平衡子树分成三部分如下图：        由于$A&gt;BR&gt;B$，所以BR结点可以连接在A的左边而不会影响排序树的性质：        两个紫色的框内的子树，高度一样，将右边框内的子树作为B的右孩子，使得B的平衡因子变为0，最后树变为平衡状态：        总结方法：    情况：在结点A的左孩子的左子树上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡。    做法：将A的左孩子B向右上旋转代替A结点，将A结点右下旋转成为B的右子树的根结点，B的原右子树变成A的左子树。            RR平衡旋转    与LL平衡旋转正好镜像。    总结方法：    情况：在结点A的右孩子的右子树上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失 去 平衡。    方法：将A的右孩子B向左上旋转代替A结点，将A结点左下旋转成为B的左子树的根结点，B的原左子树变成A的右子树。            LR平衡旋转    假设有如下的一棵排序树：        在B结点的右子树上插入一个结点：        我们注意到方形框的四个子树$BL、CL、CR、AR$之间的高度差$h\\leqslant 1$，所以它们一定要在  同  一层，我们将$A、B、C$三个结点之间的连接断掉，将这颗树进行划分：        由于$B&lt;CL&lt;C$，所以CL也可以作为B的右子树。同理，由于$C&lt;CR&lt;A$，所以CR也可以作为A的左子  树：        最后，由于$B&lt;C&lt;A$，所以A、B分别可以作C的右、左子树，最终排序树达到平衡：        总结方法：    情况：由于在A的左孩子的右子树上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去 平 衡。    方法：先将A结点的左孩子的右子树根结点C向左上旋转提升至B结点的位置，然后再向右上旋转提升   至A结点的位置。            RL平衡旋转    与RL平衡旋转正好镜像。    总结方法：    情况：由于在A的右孩子的左子树上插入新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡。    方法：先将A结点的右孩子的左子树根结点C向右上旋转提升至B结点的位置，然后再向左上旋转提升至A结点的位置。    ⚠️ LR和RL旋转时，新结点究竟插入C的左子树还是右子树不影响旋转过程。  3 平衡二叉树的删除与平衡二叉树的揷入操作类似, 以删除结点 w 为例来说明平衡二叉树删除操作的步骤:  用二叉排序树的方法对结点 w 执行删除操作。  从结点 w 开始, 向上回溯, 找到第一个不平衡的结点 $\\mathrm{z}$ (即最小不平衡子树); $\\mathrm{y}$ 为结点 $\\mathrm{z}$ 的高度最高的孩子结点; $\\mathrm{x}$ 是结点 $\\mathrm{y}$ 的高度最高的孩子结点。  然后对以 z 为根的子树进行平衡调整, 其中 x 、 y 和 z 可能的位置有 4 种情况:          $\\mathrm{y}$ 是 $\\mathrm{z}$ 的左孩子, $\\mathrm{x}$ 是 $\\mathrm{y}$ 的左孩子 (LL, 右单旋转);      $\\mathrm{y}$ 是 $\\mathrm{z}$ 的左孩子, $\\mathrm{x}$ 是 $\\mathrm{y}$ 的右孩子 (LR, 先左后右双旋转);      y 是 z 的右孩子, x 是 y 的右孩子 (RR, 左单旋转);      y 是 z 的右孩子, x 是 y 的左孩子 (RL, 先右后左双旋转)。      这四种情况与揷入操作的调整方式一样。不同之处在于, 揷入操作仅需要对以 $\\mathrm{z}$ 为根的子测 进行平衡调整；而删除操作就不一样, 先对以 $\\mathrm{z}$ 为根的子树进行平衡调整, 如果调整后子树的高度减 1, 则可能需要对 $\\mathrm{z}$ 的祖先结点进行平衡调整，甚至回溯到根结点 (导致树高减 1)。  由于上述的平衡要求并不低，而且后续的插入很容易打破平衡，所以整理操作会很频繁的进行，并且整理多数情况需要操作树的整体，这使得它的性能不怎么好，在实际的场景中应用更广泛的是红黑树。"
  }
  
]

